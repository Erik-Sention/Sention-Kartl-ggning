<!DOCTYPE html>
<html lang="en" class="index-page">
<head>
    <title>SENTION Dashboard</title>
    <link rel="icon" type="image/png" href="https://i.postimg.cc/FRwbMSBN/SENTION-logo-Black-Transparent-BG.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* ... existing code ... */
        
        /* Cell being edited styles */
        .cell-editing {
            background-color: rgba(255, 255, 0, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5);
            position: relative;
        }
        
        .cell-editing::after {
            content: "Redigeras...";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }
        
        /* Cell being edited by another user */
        .cell-editing-other {
            background-color: rgba(255, 0, 0, 0.1) !important;
            position: relative;
        }
        
        /* Editing tooltip styles */
        .editing-tooltip {
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }
        
        /* Ensure items being edited have proper positioning */
        .resource-item {
            position: relative;
        }
    </style>
    <script>
        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drag(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
        }

        function drop(ev) {
            ev.preventDefault();
            var data = ev.dataTransfer.getData("text");
            var draggedItem = document.getElementById(data);
            
            if (!draggedItem) {
                console.error("Could not find dragged item with ID:", data);
                return;
            }
            
            var target = ev.target;
            
            // Find the closest risk column
            while (target && !target.classList.contains('risk-column')) {
                target = target.parentElement;
            }
            
            if (target) {
                // Get the entity and risk level
                var entityRow = target.closest('.entity-row');
                var entity = entityRow.querySelector('.entity-title').textContent.trim();
                var riskText = target.querySelector('h3').textContent.trim();
                
                console.log("Drop target:", {
                    entity: entity,
                    riskText: riskText,
                    currentCategory: currentCategory
                });
                
                // Map the risk level text to the database format
                var riskLevel;
                if (riskText.includes('Ej risk')) riskLevel = 'No';
                else if (riskText === '游리 Risk') riskLevel = 'At';
                else if (riskText.includes('H칬g')) riskLevel = 'High';
                
                // Extract the text content from the dragged item
                var itemText = draggedItem.querySelector('.resource-item-text')?.textContent.trim() || 
                               draggedItem.textContent.replace('칑', '').trim();
                
                // Create a new item instead of cloning to ensure proper structure
                var newItem = document.createElement('div');
                newItem.className = 'resource-item';
                newItem.draggable = true;
                newItem.setAttribute('ondragstart', 'drag(event)');
                newItem.id = 'board_item_' + Math.random().toString(36).substr(2, 9);
                newItem.innerHTML = `
                    <div class="resource-item-text">${itemText}</div>
                    <button class="edit-btn" onclick="editItem(this)"><i class="bi bi-pencil"></i></button>
                    <button class="remove-btn" onclick="removeItem(this)">칑</button>`;
                
                // Determine drop position based on mouse position
                var dropY = ev.clientY;
                var insertBefore = null;
                var position = 0;
                
                // Get all existing items in the column
                var existingItems = Array.from(target.querySelectorAll('.resource-item'));
                
                // Find the item to insert before based on Y position
                for (var i = 0; i < existingItems.length; i++) {
                    var rect = existingItems[i].getBoundingClientRect();
                    var itemMiddle = rect.top + (rect.height / 2);
                    
                    if (dropY < itemMiddle) {
                        insertBefore = existingItems[i];
                        position = i;
                        break;
                    }
                }
                
                // Insert at the determined position
                if (insertBefore) {
                    target.insertBefore(newItem, insertBefore);
                } else {
                    target.appendChild(newItem);
                    position = existingItems.length;
                }
                
                console.log("Calculated position:", position);
                console.log("Saving item with category:", currentCategory);
                
                // Save to database with category
                saveToDatabase(newItem, entity, riskLevel, position, itemText);
                
                // Add touch event listeners to the new item
                if (typeof addTouchListenersToElement === 'function') {
                    addTouchListenersToElement(newItem);
                }
            } else {
                console.error("No valid drop target found");
            }
        }

        function saveToDatabase(item, entity, riskLevel, position, itemText) {
            // If itemText is not provided, extract it from the item
            if (!itemText) {
                itemText = item.querySelector('.resource-item-text')?.textContent.trim() || 
                           item.textContent.replace('칑', '').trim();
            }
            
            // If position is not provided or invalid, calculate it
            if (typeof position !== 'number' || position < 0) {
                const riskColumn = item.closest('.risk-column');
                if (riskColumn) {
                    const allItems = Array.from(riskColumn.querySelectorAll('.resource-item'));
                    position = allItems.indexOf(item);
                    console.log("Calculated position for save:", position);
                } else {
                    position = 0;
                }
            }
            
            const itemData = {
                text: itemText,
                entity: entity,
                risk_level: riskLevel,
                position: position,
                category: currentCategory
            };
            
            console.log("Saving to database:", itemData);
            
            fetch('/save_item', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(itemData)
            })
            .then(response => {
                console.log("Save response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("Save response data:", data);
                if (data.status !== 'success') {
                    console.error("Error saving item:", data.message);
                    // If there was an error, remove the item from the board
                    item.remove();
                } else {
                    console.log("Item saved successfully!");
                }
            })
            .catch(error => {
                console.error("Error saving item:", error);
                // If there was an error, remove the item from the board
                item.remove();
            });
        }

        function deleteFromDatabase(item, entity, riskLevel) {
            // Get the text content of the item
            var itemText = item.querySelector('.resource-item-text')?.textContent.trim() || 
                           item.textContent.replace('칑', '').trim();
            
            const itemData = {
                text: itemText,
                entity: entity,
                risk_level: riskLevel,
                category: currentCategory
            };
            
            console.log("Deleting from database:", itemData);
            
            fetch('/delete_item', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(itemData)
            })
            .then(response => response.json())
            .then(data => {
                console.log("Delete response:", data);
                if (data.status !== 'success') {
                    console.error("Error deleting item:", data.message);
                    // If there was an error, add the item back to the board
                    // This would be more complex in a real app
                }
            })
            .catch(error => {
                console.error("Error deleting item:", error);
            });
        }

        function removeItem(element) {
            var item = element.parentElement;
            
            // Check if this is a resource item (from the resources box)
            if (item.closest('.resources-box')) {
                // Extract the resource ID from the item ID
                const resourceId = item.id.replace('resource_', '');
                
                // If it's a valid UUID, use removeResourceItem
                if (resourceId && resourceId.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/)) {
                    removeResourceItem(element, resourceId);
                    return;
                }
                
                // Otherwise, just remove it from the DOM
                item.remove();
                return;
            }
            
            // Handle items on the board (risk categories)
            var entityRow = item.closest('.entity-row');
            var riskColumn = item.closest('.risk-column');
            
            if (entityRow && riskColumn) {
                var entity = entityRow.querySelector('.entity-title').textContent.trim();
                var riskText = riskColumn.querySelector('h3').textContent.trim();
                
                // Map the risk level text to the database format
                var riskLevel;
                if (riskText.includes('Ej risk')) riskLevel = 'No';
                else if (riskText === '游리 Risk') riskLevel = 'At';
                else if (riskText.includes('H칬g')) riskLevel = 'High';
                
                // Get the text content of the item
                var itemText = item.querySelector('.resource-item-text')?.textContent.trim() || 
                               item.textContent.replace('칑', '').trim();
                
                console.log("Removing item:", {
                    text: itemText,
                    entity: entity,
                    riskLevel: riskLevel,
                    category: currentCategory
                });
                
                // Delete from database with category
                deleteFromDatabase(item, entity, riskLevel);
                
                // Remove from DOM
                item.remove();
            }
        }

        function addNewItem() {
            var input = document.getElementById('newItemInput');
            var text = input.value.trim();

            if (text) {
                // Add to Supabase
                fetch('/add_resource', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: text })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Add resource response:", data);
                    if (data.status === 'success') {
                        console.log("Resource added successfully!");
                        // Clear input
                        input.value = '';
                        
                        // The new item will be added via the real-time subscription
                    } else {
                        console.error("Error adding resource:", data.message);
                    }
                })
                .catch(error => {
                    console.error("Error adding resource:", error);
                });
            }
        }

        // Touch event handling
        document.addEventListener('DOMContentLoaded', function() {
            // Touch event handling for draggable items
            let touchedItem = null;
            
            // Add touch event listeners to all resource items
            function addTouchListeners() {
                const items = document.querySelectorAll('.resource-item');
                items.forEach(item => {
                    item.addEventListener('touchstart', handleTouchStart, {passive: false});
                    item.addEventListener('touchmove', handleTouchMove, {passive: false});
                    item.addEventListener('touchend', handleTouchEnd, {passive: false});
                });
            }
            
            function handleTouchStart(e) {
                e.preventDefault();
                touchedItem = this;
                // Add a visual indicator that the item is being dragged
                this.style.opacity = '0.7';
            }
            
            function handleTouchMove(e) {
                e.preventDefault();
                if (!touchedItem) return;
                
                // Get touch position
                const touch = e.touches[0];
                const x = touch.clientX;
                const y = touch.clientY;
                
                // Create a visual indicator that follows the touch
                let indicator = document.getElementById('touch-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'touch-indicator';
                    indicator.style.position = 'fixed';
                    indicator.style.zIndex = '9999';
                    indicator.style.pointerEvents = 'none';
                    indicator.style.background = 'rgba(0,0,0,0.2)';
                    indicator.style.padding = '10px';
                    indicator.style.borderRadius = '5px';
                    indicator.style.width = '100px';
                    indicator.style.textAlign = 'center';
                    indicator.textContent = touchedItem.textContent.replace('칑', '').trim();
                    document.body.appendChild(indicator);
                }
                
                indicator.style.left = (x - 50) + 'px';
                indicator.style.top = (y - 25) + 'px';
            }
            
            function handleTouchEnd(e) {
                e.preventDefault();
                
                if (!touchedItem) return;
                
                // Reset visual indicator
                touchedItem.style.opacity = '1';
                
                // Get touch position
                const touchX = e.changedTouches[0].clientX;
                const touchY = e.changedTouches[0].clientY;
                
                // Find element at touch position
                const elementsAtPoint = document.elementsFromPoint(touchX, touchY);
                
                // Find the closest risk column
                const riskColumn = elementsAtPoint.find(el => el.classList.contains('risk-column'));
                
                if (riskColumn) {
                    // Get the entity and risk level
                    const entityRow = riskColumn.closest('.entity-row');
                    const entity = entityRow.querySelector('.entity-title').textContent.trim();
                    const riskText = riskColumn.querySelector('h3').textContent.trim();
                    
                    console.log("Touch drop target:", {
                        entity: entity,
                        riskText: riskText,
                        currentCategory: currentCategory
                    });
                    
                    // Map the risk level text to the database format
                    let riskLevel;
                    if (riskText.includes('Ej risk')) riskLevel = 'No';
                    else if (riskText === '游리 Risk') riskLevel = 'At';
                    else if (riskText.includes('H칬g')) riskLevel = 'High';
                    
                    // Extract the text content from the touched item
                    const itemText = touchedItem.querySelector('.resource-item-text')?.textContent.trim() || 
                                     touchedItem.textContent.replace('칑', '').trim();
                    
                    // Create a new item instead of cloning to ensure proper structure
                    const newItem = document.createElement('div');
                    newItem.className = 'resource-item';
                    newItem.draggable = true;
                    newItem.setAttribute('ondragstart', 'drag(event)');
                    newItem.id = 'board_item_' + Math.random().toString(36).substr(2, 9);
                    newItem.innerHTML = `
                        <div class="resource-item-text">${itemText}</div>
                        <button class="edit-btn" onclick="editItem(this)"><i class="bi bi-pencil"></i></button>
                        <button class="remove-btn" onclick="removeItem(this)">칑</button>`;
                    
                    // Determine drop position based on touch position
                    let insertBefore = null;
                    let position = 0;
                    
                    // Get all existing items in the column
                    const existingItems = Array.from(riskColumn.querySelectorAll('.resource-item'));
                    
                    // Find the item to insert before based on Y position
                    for (let i = 0; i < existingItems.length; i++) {
                        const rect = existingItems[i].getBoundingClientRect();
                        const itemMiddle = rect.top + (rect.height / 2);
                        
                        if (touchY < itemMiddle) {
                            insertBefore = existingItems[i];
                            position = i;
                            break;
                        }
                    }
                    
                    // Insert at the determined position
                    if (insertBefore) {
                        riskColumn.insertBefore(newItem, insertBefore);
                    } else {
                        riskColumn.appendChild(newItem);
                        position = existingItems.length;
                    }
                    
                    console.log("Touch calculated position:", position);
                    console.log("Saving touch item with category:", currentCategory);
                    
                    // Save to database with category
                    saveToDatabase(newItem, entity, riskLevel, position, itemText);
                    
                    // Add touch event listeners to the new item
                    addTouchListenersToElement(newItem);
                }
                
                // Remove the touch indicator
                const indicator = document.getElementById('touch-indicator');
                if (indicator) {
                    indicator.remove();
                }
                
                touchedItem = null;
            }
            
            // Initialize touch listeners
            addTouchListeners();
            
            // Make the function globally available
            window.addTouchListenersToElement = function(element) {
                element.addEventListener('touchstart', handleTouchStart, {passive: false});
                element.addEventListener('touchmove', handleTouchMove, {passive: false});
                element.addEventListener('touchend', handleTouchEnd, {passive: false});
            };
            
            // Add a mutation observer to add touch listeners to new items
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        addTouchListeners();
                    }
                });
            });
            
            observer.observe(document.body, { childList: true, subtree: true });
        });
    </script>
</head>
<body class="luxury-dashboard">
    <!-- Initialize Supabase client -->
    <script>
        // Initialize Supabase client
        const supabaseUrl = '{{ supabase_url }}';
        const supabaseKey = '{{ supabase_key }}';
        console.log("Supabase URL:", supabaseUrl ? "Defined" : "Undefined");
        console.log("Supabase Key:", supabaseKey ? "Defined" : "Undefined");
        
        let supabaseClient;
        try {
            // Access the global supabase object from the imported script
            supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
            console.log("Supabase client created successfully");
        } catch (error) {
            console.error("Error creating Supabase client:", error);
        }
        
        // Initialize variables from Flask
        const currentCategory = "{{ current_category }}";
        const savedItems = JSON.parse('{{ saved_items_json | safe }}' || '[]');
        const currentUserId = "{{ session.user_id }}";
        
        console.log("Current Category:", currentCategory);
        console.log("Current User ID:", currentUserId);
        console.log("Saved Items count:", savedItems.length);
        
        // Track currently edited cell
        let currentlyEditingCell = null;
        let isCurrentlySaving = false;
        
        // Track cells being edited by other users
        const cellsBeingEditedByOthers = new Map(); // Map of "rowIndex-colIndex" to user ID
        
        // Generate a unique user ID for this session
        const sessionUserId = generateUUID();
        
        // Set up real-time subscription for editing status
        function setupEditingSubscription() {
            console.log("Setting up editing status subscription...");
            
            if (!supabaseClient) {
                console.error("Supabase client not initialized, can't set up subscription");
                return null;
            }
            
            // Subscribe to the editing status channel
            const editingChannel = supabaseClient.channel('editing_status')
                .on(
                    'broadcast',
                    { event: 'editing' },
                    (payload) => {
                        handleEditingStatus(payload);
                    }
                )
                .subscribe();
                
            // Set up a heartbeat to keep editing status alive
            setInterval(() => {
                if (currentlyEditingCell) {
                    // Re-broadcast our editing status every 5 seconds to keep it alive
                    broadcastEditingStatus(currentlyEditingCell, true);
                }
            }, 5000);
            
            return editingChannel;
        }
        
        // Handle editing status updates
        function handleEditingStatus(payload) {
            console.log('Editing status update:', payload);
            
            const { userId, elementId, isEditing } = payload.payload;
            
            // Find the element
            const element = document.getElementById(elementId);
            if (!element) {
                console.log('Element not found:', elementId);
                return;
            }

            // If this is our own update, only update currentlyEditingCell
            if (userId === sessionUserId) {
                if (isEditing) {
                    currentlyEditingCell = element;
                } else {
                    currentlyEditingCell = null;
                }
                return;
            }

            // Handle updates from other users
            if (isEditing) {
                // Another user is editing this element
                element.classList.add('cell-editing-other');
                element.setAttribute('contenteditable', 'false'); // Prevent editing
                cellsBeingEditedByOthers.set(elementId, userId);
                
                // Add tooltip to show who is editing
                const tooltip = document.createElement('div');
                tooltip.className = 'editing-tooltip';
                tooltip.textContent = 'Redigeras av annan anv칛ndare';
                element.appendChild(tooltip);
            } else {
                // User stopped editing
                element.classList.remove('cell-editing-other');
                element.setAttribute('contenteditable', 'true'); // Allow editing again
                cellsBeingEditedByOthers.delete(elementId);
                
                // Remove tooltip
                const tooltip = element.querySelector('.editing-tooltip');
                if (tooltip) {
                    tooltip.remove();
                }
            }

            // Update the visual state of all items
            applyEditingIndicators();
        }
        
        // Broadcast editing status
        function broadcastEditingStatus(element, isEditing) {
            // Broadcast editing status
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'editing',
                payload: {
                    userId: sessionUserId,
                    elementId: element.id,
                    isEditing
                }
            });
        }
        
        // Apply editing indicators for elements being edited by others
        function applyEditingIndicators() {
            // First, clear all editing indicators
            document.querySelectorAll('.cell-editing-other').forEach(element => {
                if (!cellsBeingEditedByOthers.has(element.id)) {
                    element.classList.remove('cell-editing-other');
                    element.setAttribute('contenteditable', 'true');
                    const tooltip = element.querySelector('.editing-tooltip');
                    if (tooltip) {
                        tooltip.remove();
                    }
                }
            });

            // Then apply current editing states
            cellsBeingEditedByOthers.forEach((userId, elementId) => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.classList.add('cell-editing-other');
                    element.setAttribute('contenteditable', 'false');
                    
                    // Ensure tooltip exists
                    if (!element.querySelector('.editing-tooltip')) {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'editing-tooltip';
                        tooltip.textContent = 'Redigeras av annan anv칛ndare';
                        element.appendChild(tooltip);
                    }
                }
            });
        }
        
        // Function to generate UUID for elements
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // Set up real-time subscription for items
        const setupRealtimeSubscription = () => {
            console.log("Setting up real-time subscription for items...");
            
            if (!supabaseClient) {
                console.error("Supabase client not initialized, can't set up subscription");
                return null;
            }
            
            console.log("Creating channel for category:", currentCategory);
            
            // Subscribe to changes in the items table for the current category
            const subscription = supabaseClient
                .channel('items-changes')
                .on('postgres_changes', {
                    event: '*',  // Listen for all events (INSERT, UPDATE, DELETE)
                    schema: 'public',
                    table: 'items',
                    filter: `category=eq.${currentCategory}`
                }, (payload) => {
                    console.log("Real-time event received:", payload);
                    handleRealtimeChange(payload);
                })
                .subscribe((status) => {
                    console.log("Subscription status:", status);
                    
                    if (status === 'SUBSCRIBED') {
                        console.log("Successfully subscribed to real-time changes!");
                    } else if (status === 'CHANNEL_ERROR') {
                        console.error("Error subscribing to real-time changes");
                    }
                    
                    // Initialize touch listeners after subscription is set up
                    setTimeout(addTouchListeners, 500);
                });
                
            return subscription;
        };
        
        // Handle real-time changes
        const handleRealtimeChange = (payload) => {
            console.log("Real-time change received:", payload);
            
            const { eventType, new: newItem, old: oldItem } = payload;
            
            // Only process items for the current category
            if (newItem && newItem.category !== currentCategory) {
                console.log('Ignoring item from different category:', newItem.category);
                return;
            }
            
            switch (eventType) {
                case 'INSERT':
                    // Don't add items that were just added by this user (to avoid duplicates)
                    if (newItem.user_id === currentUserId) {
                        console.log('Ignoring own insert');
                        return;
                    }
                    addItemToBoard(newItem);
                    break;
                    
                case 'DELETE':
                    removeItemFromBoard(oldItem);
                    break;
                    
                case 'UPDATE':
                    // Update the item in place instead of removing and re-adding
                    updateItemInBoard(newItem, oldItem);
                    break;
            }
        };
        
        // Update item in the board without changing its position
        const updateItemInBoard = (newItem, oldItem) => {
            console.log("Updating item in board:", newItem);
            
            // Map risk levels to the exact text in your columns
            const riskMap = {
                'No': '游릭 Ej risk',
                'At': '游리 Risk',
                'High': '游댮 H칬g risk'
            };
            
            // Find the entity row
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent.trim() === newItem.entity);
            
            if (entityRow) {
                // Find the risk column
                const riskColumn = Array.from(entityRow.querySelectorAll('.risk-column'))
                    .find(col => col.querySelector('h3').textContent.trim() === riskMap[newItem.risk_level]);
                
                if (riskColumn) {
                    // Try to find an existing item with the same text as the old item
                    const existingItems = Array.from(riskColumn.querySelectorAll('.resource-item'));
                    const existingItem = existingItems.find(el => {
                        const itemText = el.querySelector('.resource-item-text')?.textContent.trim() || 
                                        el.textContent.replace('칑', '').trim();
                        return itemText === oldItem.text;
                    });
                    
                    if (existingItem) {
                        // Update the existing item's text
                        const textContainer = existingItem.querySelector('.resource-item-text');
                        if (textContainer) {
                            textContainer.textContent = newItem.text;
                            console.log("Updated item text in place:", newItem.text);
                            return; // Exit early - we've updated the text in place
                        } else {
                            // If there's no text container, update the whole item
                            existingItem.innerHTML = `
                                <div class="resource-item-text">${newItem.text}</div>
                                <button class="edit-btn" onclick="editItem(this)"><i class="bi bi-pencil"></i></button>
                                <button class="remove-btn" onclick="removeItem(this)">칑</button>`;
                            
                            // Add touch event listeners to the updated item
                            if (typeof addTouchListenersToElement === 'function') {
                                addTouchListenersToElement(existingItem);
                            }
                            console.log("Updated entire item in place:", newItem.text);
                            return; // Exit early - we've updated the item in place
                        }
                    }
                    
                    // If we're here, we couldn't find the item by text, try to find it by position
                    if (typeof newItem.position === 'number') {
                        // Get all items in this risk column
                        const allItems = Array.from(riskColumn.querySelectorAll('.resource-item'));
                        
                        // Check if there's an item at this position
                        if (newItem.position >= 0 && newItem.position < allItems.length) {
                            const itemAtPosition = allItems[newItem.position];
                            
                            // Update the item at this position
                            const textContainer = itemAtPosition.querySelector('.resource-item-text');
                            if (textContainer) {
                                textContainer.textContent = newItem.text;
                                console.log("Updated item at position", newItem.position, ":", newItem.text);
                                return; // Exit early - we've updated the item at the position
                            }
                        }
                    }
                }
            }
            
            // If we couldn't find the item to update, fall back to remove and add
            console.log("Could not find item to update in place, falling back to remove and add");
            removeItemFromBoard(oldItem);
            addItemToBoard(newItem);
        };
        
        // Add item to the board
        const addItemToBoard = (item) => {
            console.log('Adding item to board:', item);
            
            // Map risk levels to the exact text in your columns
            const riskMap = {
                'No': '游릭 Ej risk',
                'At': '游리 Risk',
                'High': '游댮 H칬g risk'
            };
            
            // Skip items with Unknown risk level
            if (item.risk_level === 'Unknown') {
                console.log('Skipping item with Unknown risk level:', item.text);
                return;
            }
            
            // Find the entity row
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent.trim() === item.entity);
            
            console.log('Found entity row:', entityRow?.querySelector('.entity-title')?.textContent);
            
            if (entityRow) {
                // Find the risk column using the mapped risk level
                const riskColumn = Array.from(entityRow.querySelectorAll('.risk-column'))
                    .find(col => col.querySelector('h3').textContent.trim() === riskMap[item.risk_level]);
                
                console.log('Found risk column:', riskColumn?.querySelector('h3')?.textContent);
                
                if (riskColumn) {
                    // Check if item already exists (to avoid duplicates)
                    const existingItems = Array.from(riskColumn.querySelectorAll('.resource-item'));
                    const itemExists = existingItems.some(el => 
                        el.textContent.replace('칑', '').trim() === item.text);
                    
                    if (!itemExists) {
                        // Create new item
                        const newItem = document.createElement('div');
                        newItem.className = 'resource-item';
                        newItem.draggable = true;
                        newItem.setAttribute('ondragstart', 'drag(event)');
                        newItem.id = `realtime_${Math.random().toString(36).substr(2, 9)}`;
                        newItem.innerHTML = `
                            <div class="resource-item-text">${item.text}</div>
                            <button class="edit-btn" onclick="editItem(this)"><i class="bi bi-pencil"></i></button>
                            <button class="remove-btn" onclick="removeItem(this)">칑</button>`;
                        
                        // Insert at the correct position if specified
                        if (typeof item.position === 'number' && item.position >= 0) {
                            console.log('Inserting item at position:', item.position);
                            
                            // Get all existing items
                            const allItems = Array.from(riskColumn.querySelectorAll('.resource-item'));
                            
                            if (item.position < allItems.length) {
                                // Insert before the item at the specified position
                                riskColumn.insertBefore(newItem, allItems[item.position]);
                            } else {
                                // If position is beyond the current items, just append
                                riskColumn.appendChild(newItem);
                            }
                        } else {
                            // If no position specified, just append
                            riskColumn.appendChild(newItem);
                        }
                        
                        console.log('Added item:', item.text);
                        
                        // Add touch event listeners to the new item
                        if (typeof addTouchListenersToElement === 'function') {
                            addTouchListenersToElement(newItem);
                        }
                    }
                }
            }
        };
        
        // Remove item from the board
        const removeItemFromBoard = (item) => {
            console.log('Removing item from board:', item);
            
            // Skip items with Unknown risk level
            if (item.risk_level === 'Unknown') {
                console.log('Skipping removal of item with Unknown risk level:', item.text);
                return;
            }
            
            // Map risk levels to the exact text in your columns
            const riskMap = {
                'No': '游릭 Ej risk',
                'At': '游리 Risk',
                'High': '游댮 H칬g risk'
            };
            
            // Find the entity row
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent.trim() === item.entity);
            
            if (entityRow) {
                // Find the risk column
                const riskColumn = Array.from(entityRow.querySelectorAll('.risk-column'))
                    .find(col => col.querySelector('h3').textContent.trim() === riskMap[item.risk_level]);
                
                if (riskColumn) {
                    // Find the item by text content
                    const itemElements = Array.from(riskColumn.querySelectorAll('.resource-item'));
                    const itemToRemove = itemElements.find(el => 
                        el.textContent.replace('칑', '').trim() === item.text);
                    
                    if (itemToRemove) {
                        itemToRemove.remove();
                        console.log('Removed item:', item.text);
                    }
                }
            }
        };
    
        // Set up real-time subscription for resources
        const setupResourcesSubscription = () => {
            console.log("Setting up real-time subscription for resources...");
            
            if (!supabaseClient) {
                console.error("Supabase client not initialized, can't set up subscription");
                return null;
            }
            
            // Subscribe to changes in the resources table
            const subscription = supabaseClient
                .channel('resources-changes')
                .on('postgres_changes', {
                    event: '*',  // Listen for all events (INSERT, UPDATE, DELETE)
                    schema: 'public',
                    table: 'resources'
                }, (payload) => {
                    console.log("Resources real-time event received:", payload);
                    handleResourcesRealtimeChange(payload);
                })
                .subscribe((status) => {
                    console.log("Resources subscription status:", status);
                });
                
            return subscription;
        };
        
        // Handle real-time changes for resources
        const handleResourcesRealtimeChange = (payload) => {
            console.log("Resources real-time change received:", payload);
            
            const { eventType, new: newResource, old: oldResource } = payload;
            
            switch (eventType) {
                case 'INSERT':
                    addResourceToList(newResource);
                    break;
                    
                case 'DELETE':
                    removeResourceFromList(oldResource.id);
                    break;
                    
                case 'UPDATE':
                    // Update the resource in place instead of removing and re-adding
                    updateResourceInList(newResource);
                    break;
            }
        };
        
        // Add resource to the list
        const addResourceToList = (resource) => {
            console.log("Adding resource to list:", resource);
            
            const container = document.querySelector('.resources-box');
            
            // Check if resource already exists
            const existingResource = document.getElementById(`resource_${resource.id}`);
            if (existingResource) {
                console.log("Resource already exists, updating:", resource.id);
                updateResourceContent(existingResource, resource);
                return;
            }
            
            // Create new resource item
            const newItem = document.createElement('div');
            newItem.id = `resource_${resource.id}`;
            newItem.className = 'resource-item';
            newItem.draggable = true;
            newItem.setAttribute('ondragstart', 'drag(event)');
            updateResourceContent(newItem, resource);
            
            // Add to container
            container.appendChild(newItem);
            
            // Add touch event listeners to the new item
            if (typeof addTouchListenersToElement === 'function') {
                addTouchListenersToElement(newItem);
            }
        };
        
        // Update resource in the list without changing its position
        const updateResourceInList = (resource) => {
            console.log("Updating resource in list:", resource);
            
            const existingResource = document.getElementById(`resource_${resource.id}`);
            if (existingResource) {
                updateResourceContent(existingResource, resource);
            } else {
                // If the resource doesn't exist (shouldn't happen), add it
                addResourceToList(resource);
            }
        };
        
        // Helper function to update resource content
        const updateResourceContent = (element, resource) => {
            element.innerHTML = `
                <div class="resource-item-text">${resource.text}</div>
                <button class="edit-btn" onclick="editResourceItem(this, '${resource.id}')"><i class="bi bi-pencil"></i></button>
                <button class="remove-btn" onclick="removeResourceItem(this, '${resource.id}')">칑</button>
            `;
        };
        
        // Remove resource from the list
        const removeResourceFromList = (resourceId) => {
            console.log("Removing resource from list:", resourceId);
            
            const item = document.getElementById(`resource_${resourceId}`);
            if (item) {
                item.remove();
            }
        };
        
        // Remove resource item (button click handler)
        function removeResourceItem(element, resourceId) {
            console.log("Removing resource item:", resourceId);
            
            // Delete from Supabase
            fetch('/delete_resource', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ id: resourceId })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Delete resource response:", data);
                if (data.status === 'success') {
                    console.log("Resource deleted successfully!");
                    // The item will be removed via the real-time subscription
                } else {
                    console.error("Error deleting resource:", data.message);
                }
            })
            .catch(error => {
                console.error("Error deleting resource:", error);
            });
        }
        
        // Load resources when the page loads
        function loadResources() {
            console.log('Loading resources...');
            
            fetch('/get_resources')
                .then(response => response.json())
                .then(data => {
                    console.log("Get resources response:", data);
                    if (data.status === 'success') {
                        // Clear existing resources
                        const container = document.querySelector('.resources-box');
                        // Keep the heading
                        const heading = container.querySelector('h3');
                        container.innerHTML = '';
                        container.appendChild(heading);
                        
                        // Add resources
                        data.resources.forEach(resource => {
                            addResourceToList(resource);
                        });
                    } else {
                        console.error("Error getting resources:", data.message);
                    }
                })
                .catch(error => {
                    console.error("Error getting resources:", error);
                });
        }
        
        // Load saved items when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Loading saved items...');
            
            // Load initial items
            savedItems.forEach(item => {
                console.log('Processing item:', item);
                
                // Only process items for the current category
                if (item.category !== currentCategory) {
                    console.log('Skipping item from different category:', item.category);
                    return;
                }
                
                // Add item to board
                addItemToBoard(item);
            });
            
            // Set up real-time subscription for items
            const itemsSubscription = setupRealtimeSubscription();
            
            // Set up real-time subscription for editing status
            const editingSubscription = setupEditingSubscription();
            
            // Load resources
            loadResources();
            
            // Set up real-time subscription for resources
            const resourcesSubscription = setupResourcesSubscription();
            
            // Clean up subscriptions when page unloads
            window.addEventListener('beforeunload', () => {
                console.log('Cleaning up subscriptions...');
                
                // Broadcast that we stopped editing any item
                if (currentlyEditingCell) {
                    broadcastEditingStatus(currentlyEditingCell, false);
                }
                
                if (itemsSubscription) itemsSubscription.unsubscribe();
                if (editingSubscription) editingSubscription.unsubscribe();
                if (resourcesSubscription) resourcesSubscription.unsubscribe();
            });
        });

        // Add these new functions for editing resources and items
        function editResourceItem(element, resourceId) {
            const item = element.closest('.resource-item');
            const textContainer = item.querySelector('.resource-item-text');
            const currentText = textContainer.textContent.trim();
            
            // Create an input field for editing
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.className = 'edit-input';
            
            // Create save button
            const saveBtn = document.createElement('button');
            saveBtn.className = 'save-edit-btn';
            saveBtn.innerHTML = '<i class="bi bi-check"></i>';
            saveBtn.onclick = function() {
                saveResourceEdit(resourceId, input.value, item);
            };
            
            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'cancel-edit-btn';
            cancelBtn.innerHTML = '<i class="bi bi-x"></i>';
            cancelBtn.onclick = function() {
                cancelEdit(item, currentText);
            };
            
            // Clear the item and add the input field and buttons
            item.innerHTML = '';
            item.appendChild(input);
            item.appendChild(saveBtn);
            item.appendChild(cancelBtn);
            
            // Focus the input field
            input.focus();
            
            // Disable dragging during edit
            item.draggable = false;
        }
        
        function saveResourceEdit(resourceId, newText, item) {
            // Save to database
            fetch('/update_resource', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    id: resourceId,
                    text: newText
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log("Update resource response:", data);
                if (data.status === 'success') {
                    console.log("Resource updated successfully!");
                    // The item will be updated via the real-time subscription
                } else {
                    console.error("Error updating resource:", data.message);
                    // Restore the original text
                    cancelEdit(item, newText);
                }
            })
            .catch(error => {
                console.error("Error updating resource:", error);
                // Restore the original text
                cancelEdit(item, newText);
            });
        }
        
        function editItem(element) {
            const item = element.closest('.resource-item');
            
            // If item is being edited by another user, don't allow editing
            if (item.classList.contains('cell-editing-other')) {
                return;
            }
            
            // Ensure the item has an ID
            if (!item.id) {
                item.id = 'item_' + generateUUID();
            }
            
            // Mark as being edited
            currentlyEditingCell = item;
            item.classList.add('cell-editing');
            
            // Broadcast editing status
            broadcastEditingStatus(item, true);
            
            // Rest of the existing editItem code...
            const textContainer = item.querySelector('.resource-item-text');
            const currentText = textContainer ? textContainer.textContent.trim() : item.textContent.replace('칑', '').trim();
            
            // Get entity and risk level for later use
            const entityRow = item.closest('.entity-row');
            const riskColumn = item.closest('.risk-column');
            const entity = entityRow.querySelector('.entity-title').textContent.trim();
            const riskText = riskColumn.querySelector('h3').textContent.trim();
            
            // Map the risk level text to the database format
            let riskLevel;
            if (riskText.includes('Ej risk')) riskLevel = 'No';
            else if (riskText.includes('Risk') && !riskText.includes('H칬g')) riskLevel = 'At';
            else if (riskText.includes('H칬g')) riskLevel = 'High';
            else riskLevel = 'Unknown';
            
            // Get all resource items in this risk column
            const allItems = Array.from(riskColumn.querySelectorAll('.resource-item'));
            
            // Store the item's position in the DOM for later use
            // We need to filter to only count resource-item elements
            const itemPosition = allItems.indexOf(item);
            console.log("Editing item at position:", itemPosition);
            
            // Store position and other data as attributes
            item.dataset.position = itemPosition;
            item.dataset.entity = entity;
            item.dataset.riskLevel = riskLevel;
            item.dataset.originalText = currentText;
            
            // Create an input field for editing
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.className = 'edit-input';
            
            // Create save button
            const saveBtn = document.createElement('button');
            saveBtn.className = 'save-edit-btn';
            saveBtn.innerHTML = '<i class="bi bi-check"></i>';
            saveBtn.onclick = function() {
                saveItemEdit(input.value, currentText, entity, riskLevel, item);
            };
            
            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'cancel-edit-btn';
            cancelBtn.innerHTML = '<i class="bi bi-x"></i>';
            cancelBtn.onclick = function() {
                cancelEdit(item, currentText);
            };
            
            // Clear the item and add the input field and buttons
            item.innerHTML = '';
            item.appendChild(input);
            item.appendChild(saveBtn);
            item.appendChild(cancelBtn);
            
            // Focus the input field
            input.focus();
            
            // Disable dragging during edit
            item.draggable = false;
        }
        
        function saveItemEdit(newText, oldText, entity, riskLevel, item) {
            // Get the stored position from the item's dataset
            const position = parseInt(item.dataset.position);
            console.log("Saving edited item with position:", position);
            
            // First delete the old item
            const deleteData = {
                text: oldText,
                entity: entity,
                risk_level: riskLevel,
                category: currentCategory
            };
            
            fetch('/delete_item', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(deleteData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // Then save the new item with the same position
                    const saveData = {
                        text: newText,
                        entity: entity,
                        risk_level: riskLevel,
                        position: position, // Use the stored position
                        category: currentCategory
                    };
                    
                    fetch('/save_item', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(saveData)
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status !== 'success') {
                            console.error("Error saving edited item:", data.message);
                            // Restore the original text
                            cancelEdit(item, oldText);
                        } else {
                            // Manually restore the item appearance since the realtime update might be delayed
                            cancelEdit(item, newText);
                        }
                    })
                    .catch(error => {
                        console.error("Error saving edited item:", error);
                        // Restore the original text
                        cancelEdit(item, oldText);
                    });
                } else {
                    console.error("Error deleting old item:", data.message);
                    // Restore the original text
                    cancelEdit(item, oldText);
                }
            })
            .catch(error => {
                console.error("Error deleting old item:", error);
                // Restore the original text
                cancelEdit(item, oldText);
            });
        }
        
        function cancelEdit(item, originalText) {
            // Broadcast that we stopped editing
            if (item.id) {
                broadcastEditingStatus(item, false);
            }
            
            // Clear currently editing cell if it's this one
            if (currentlyEditingCell === item) {
                currentlyEditingCell = null;
            }
            
            // Remove editing indicator
            item.classList.remove('cell-editing');
            
            // Rest of the existing cancelEdit code...
            if (item.id.startsWith('resource_')) {
                const resourceId = item.id.replace('resource_', '');
                item.innerHTML = `
                    <div class="resource-item-text">${originalText}</div>
                    <button class="edit-btn" onclick="editResourceItem(this, '${resourceId}')"><i class="bi bi-pencil"></i></button>
                    <button class="remove-btn" onclick="removeResourceItem(this, '${resourceId}')">칑</button>
                `;
            } else {
                item.innerHTML = `
                    <div class="resource-item-text">${originalText}</div>
                    <button class="edit-btn" onclick="editItem(this)"><i class="bi bi-pencil"></i></button>
                    <button class="remove-btn" onclick="removeItem(this)">칑</button>
                `;
            }
            
            // Re-enable dragging
            item.draggable = true;
            
            // Add touch event listeners back to the item
            if (typeof addTouchListenersToElement === 'function') {
                addTouchListenersToElement(item);
            }
        }
    </script>
    
    <div class="header">
        <h2>SENTION Kartl칛ggning</h2>
        <div class="navbar-links">
            <a href="{{ url_for('home', category='anstalld') }}" class="{{ 'active' if current_category == 'anstalld' else '' }}">Anst칛lld</a>
            <a href="{{ url_for('home', category='grupp') }}" class="{{ 'active' if current_category == 'grupp' else '' }}">Grupp</a>
            <a href="{{ url_for('home', category='organisation') }}" class="{{ 'active' if current_category == 'organisation' else '' }}">Organisation</a>
            <a href="{{ url_for('home', category='foretagsledning') }}" class="{{ 'active' if current_category == 'foretagsledning' else '' }}">F칬retagsledning</a>
            <a href="{{ url_for('home', category='managers') }}" class="{{ 'active' if current_category == 'managers' else '' }}">Managers L6</a>
            <a href="{{ url_for('home', category='supervisors') }}" class="{{ 'active' if current_category == 'supervisors' else '' }}">Supervisors AC</a>
            <a href="{{ url_for('home', category='system') }}" class="{{ 'active' if current_category == 'system' else '' }}">System</a>
        </div>
        <div class="nav-buttons">
            <a href="{{ url_for('profile') }}" class="profile-btn"><i class="bi bi-person"></i> Min profil</a>
            {% if session.role == 'admin' %}
            <a href="{{ url_for('admin_users') }}" class="admin-btn"><i class="bi bi-gear"></i> Anv칛ndarhantering</a>
            {% endif %}
            <a href="{{ url_for('logout') }}" class="logout-btn"><i class="bi bi-box-arrow-right"></i> Logga ut</a>
        </div>
    </div>
    <div class="resources-box">
        <h3>Tillg칛ngliga resurser</h3>
        <!-- Resources will be loaded dynamically from Supabase -->
    </div>

    <div class="add-item-form">
        <input type="text" id="newItemInput" placeholder="Skriv ny resurs h칛r">
        <button onclick="addNewItem()">L칛gg till</button>
    </div>

    <!-- HR Row -->
    <div class="entity-row">
        <div class="entity-title">HR</div>
        <div class="risk-columns">
            <div class="risk-column no-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游릭 Ej risk</h3>
            </div>
            <div class="risk-column at-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游리 Risk</h3>
            </div>
            <div class="risk-column high-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游댮 H칬g risk</h3>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">俱 R칛tt riskgrupp i r칛tt tid</div>
            <div class="indicator">俱돽룻 Anv칛nds i 칬nskad utstr칛ckning</div>
            <div class="indicator">俱돽룻俱 Har avsedd effekt</div>
        </div>
    </div>

    <!-- Company Health Row -->
    <div class="entity-row">
        <div class="entity-title">F칬retagsh칛lsov친rd</div>
        <div class="risk-columns">
            <div class="risk-column no-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游릭 Ej risk</h3>
            </div>
            <div class="risk-column at-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游리 Risk</h3>
            </div>
            <div class="risk-column high-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游댮 H칬g risk</h3>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">俱 R칛tt riskgrupp i r칛tt tid</div>
            <div class="indicator">俱돽룻 Anv칛nds i 칬nskad utstr칛ckning</div>
            <div class="indicator">俱돽룻俱 Har avsedd effekt</div>
        </div>
    </div>

    <!-- Other Providers Row -->
    <div class="entity-row">
        <div class="entity-title">Specialistinterventioner</div>
        <div class="risk-columns">
            <div class="risk-column no-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游릭 Ej risk</h3>
            </div>
            <div class="risk-column at-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游리 Risk</h3>
            </div>
            <div class="risk-column high-risk" ondrop="drop(event)" ondragover="allowDrop(event)">
                <h3>游댮 H칬g risk</h3>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">俱 R칛tt riskgrupp i r칛tt tid</div>
            <div class="indicator">俱돽룻 Anv칛nds i 칬nskad utstr칛ckning</div>
            <div class="indicator">俱돽룻俱 Har avsedd effekt</div>
        </div>
    </div>

    <!-- Login/Signup Forms -->
    {% if not session.get('user_id') %}
        <!-- Login Form -->
        <div class="auth-form">
            <h3>Login</h3>
            <form action="/login" method="post">
                <div class="form-group">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" name="email" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" name="password" required>
                </div>
                <button type="submit" class="btn btn-primary">Login</button>
            </form>
        </div>
        
        <!-- Signup Form -->
        <div class="auth-form">
            <h3>Sign Up</h3>
            <form action="/signup" method="post">
                <div class="form-group">
                    <label for="signup-username">Username</label>
                    <input type="text" id="signup-username" name="username" required>
                </div>
                <div class="form-group">
                    <label for="signup-email">Email</label>
                    <input type="email" id="signup-email" name="email" required>
                </div>
                <div class="form-group">
                    <label for="signup-password">Password</label>
                    <input type="password" id="signup-password" name="password" required>
                </div>
                <div class="form-group">
                    <label for="signup-fullname">Full Name</label>
                    <input type="text" id="signup-fullname" name="full_name">
                </div>
                <button type="submit" class="btn btn-primary">Sign Up</button>
            </form>
        </div>
    {% endif %}
</body>
</html>
