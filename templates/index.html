<!DOCTYPE html>
<html lang="en" class="index-page">
<head>
    <title>SENTION Dashboard</title>
    <link rel="icon" type="image/png" href="https://i.postimg.cc/FRwbMSBN/SENTION-logo-Black-Transparent-BG.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Rating selector styles */
        .rating-selector {
            position: absolute;
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 10px;
            z-index: 100;
            display: none;
        }
        
        .rating-option {
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 5px;
            transition: background-color 0.2s;
        }
        
        .rating-option:hover {
            background-color: #f8f9fa;
        }

        /* Add button styles */
        .add-item-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border-radius: 6px;
            background-color: #F0EEEC;
            color: #333;
            border: none;
            cursor: pointer;
            margin: 10px auto;
        }

        .add-item-btn:hover {
            background-color: #e0dedc;
        }

        /* Item styles */
        .item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin: 5px;
            background-color: #F7F6F5;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .item:hover {
            background-color: #F0EEEC;
        }
        
        /* Drag handle styles */
        .drag-handle {
            cursor: move;
            color: #6c757d;
            padding: 5px;
            margin-right: 5px;
            opacity: 0.5;
            transition: all 0.2s;
            position: relative;
        }
        
        .drag-handle:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #0d6efd;
        }
        
        .drag-handle::after {
            content: 'Dra fÃ¶r att Ã¤ndra ordning';
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            z-index: 1000;
        }
        
        .drag-handle:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        /* Dragging styles */
        .item.dragging {
            background-color: rgba(0, 123, 255, 0.1) !important;
            opacity: 0.8;
            cursor: move;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .item.drag-over {
            position: relative;
        }
        
        .item.drag-over::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: -2px;
            height: 4px;
            background-color: #0d6efd;
            z-index: 100;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            animation: pulse 1.5s infinite;
        }

        /* Container drag-over styles */
        .items-container.container-drag-over {
            background-color: rgba(13, 110, 253, 0.05);
            border: 2px dashed #0d6efd;
            border-radius: 6px;
            padding: 10px;
            min-height: 60px;
            animation: pulse 1.5s infinite;
        }

        .item-text {
            flex-grow: 1;
            margin-right: 10px;
            min-height: 20px;
        }

        .item-text[contenteditable="true"] {
            padding: 2px;
            outline: none;
        }

        .item-rating {
            padding: 2px 5px;
            color: #666;
            min-width: 60px;
            text-align: center;
        }
        
        /* Add placeholder for empty rating */
        .item-rating:empty::before {
            content: "Klicka fÃ¶r betyg";
            font-style: italic;
            color: #aaa;
            font-size: 0.85em;
        }

        /* Delete button styles */
        .delete-btn {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .item:hover .delete-btn {
            opacity: 1;
        }
        
        .delete-btn:hover {
            color: #bd2130;
        }

        /* Edit mode styles */
        .editing {
            background-color: #fff;
            box-shadow: 0 0 0 2px #007bff;
        }

        .editing .delete-btn {
            opacity: 1;
        }

        /* Entity row styles */
        .entity-row {
            margin: 20px;
            width: calc(100% - 40px); /* Full width minus margins */
            max-width: 100%;
            box-sizing: border-box;
        }

        .risk-columns {
            display: flex;
            gap: 20px;
            width: 100%;
            margin-top: 10px;
        }

        .risk-column {
            flex: 1;
            border-radius: 8px;
            padding: 15px;
            min-width: 0; /* Prevents flex items from overflowing */
        }

        .risk-column.no-risk {
            background-color: rgba(40, 167, 69, 0.1); /* Light green */
        }

        .risk-column.at-risk {
            background-color: rgba(255, 193, 7, 0.1); /* Light yellow */
        }

        .risk-column.high-risk {
            background-color: rgba(220, 53, 69, 0.1); /* Light red */
        }

        .items-container {
            width: 100%;
        }

        /* Cell being edited styles */
        .cell-editing {
            background-color: rgba(255, 255, 0, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5);
            position: relative;
        }

        .cell-editing::after {
            content: "Redigeras...";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Cell being edited by another user */
        .cell-editing-other {
            background-color: rgba(255, 0, 0, 0.1) !important;
            position: relative;
        }

        .cell-editing-other::after {
            content: "Redigeras av annan anvÃ¤ndare";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Status message styles */
        .status-message {
            margin: 15px 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        
        .success-message {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* Auto-save indicator */
        .auto-save-indicator {
            display: inline-block;
            margin: 15px 20px;
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        /* Saving animation */
        .saving {
            display: inline-block;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        /* First-time user hint */
        .drag-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            padding: 12px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            color: #666;
            z-index: 1000;
            animation: slideIn 0.5s ease-out;
            max-width: 450px;
            width: 450px;
            min-height: 60px;
            height: 60px;
        }
        
        .drag-hint i {
            font-size: 1.2rem;
            color: #0d6efd;
        }
        
        .drag-hint-content {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        
        #drag-hint-text {
            transition: opacity 0.3s ease;
            min-height: 24px;
            display: flex;
            align-items: center;
            overflow: hidden;
            line-height: 1.4;
            flex-grow: 1;
        }
        
        .tip-navigation {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
            white-space: nowrap;
        }
        
        .tip-nav-btn {
            background: none;
            border: none;
            color: #0d6efd;
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .tip-nav-btn:hover {
            background-color: rgba(13, 110, 253, 0.1);
            transform: scale(1.1);
        }
        
        .tip-counter {
            font-size: 0.8rem;
            color: #999;
        }
        
        .drag-hint-close {
            margin-left: 10px;
            padding: 5px;
            cursor: pointer;
            color: #999;
            transition: color 0.2s;
        }
        
        .drag-hint-close:hover {
            color: #666;
        }
        
        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #333;
        }
        
        .shortcuts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .shortcuts-table tr {
            border-bottom: 1px solid #eee;
        }
        
        .shortcuts-table tr:last-child {
            border-bottom: none;
        }
        
        .shortcuts-table td {
            padding: 8px 5px;
        }
        
        .shortcuts-table td:first-child {
            width: 40%;
            text-align: right;
            padding-right: 15px;
        }
        
        kbd {
            background-color: #f7f7f7;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
            color: #333;
            display: inline-block;
            font-size: 0.85em;
            font-family: monospace;
            line-height: 1;
            padding: 2px 5px;
            margin: 0 2px;
        }
        
        /* Help button styles */
        .help-btn {
            background-color: #6c757d;
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            text-decoration: none;
            margin-left: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: background-color 0.2s;
        }
        
        .help-btn:hover {
            background-color: #5a6268;
            color: white;
        }
        
        .help-btn i {
            font-size: 1.1rem;
        }
        
        /* Welcome modal styles */
        .welcome-content {
            max-width: 600px;
            padding: 25px;
        }
        
        .welcome-steps {
            margin: 20px 0;
        }
        
        .welcome-step {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }
        
        .step-number {
            background-color: #0d6efd;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex-grow: 1;
        }
        
        .step-content h4 {
            margin: 0 0 5px 0;
            color: #333;
        }
        
        .step-content p {
            margin: 0;
            color: #666;
            line-height: 1.5;
        }
        
        .welcome-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .welcome-btn {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .welcome-btn:hover {
            background-color: #0b5ed7;
        }
        
        .dont-show-again {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #666;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* Help floating button */
        .help-floating-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #0d6efd;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 999;
            transition: all 0.2s;
            opacity: 0;
            visibility: hidden;
        }
        
        .help-floating-btn.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .help-floating-btn:hover {
            transform: scale(1.1);
            background-color: #0b5ed7;
        }
        
        .help-floating-btn i {
            font-size: 1.2rem;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Container styles to ensure consistent margins */
        .container {
            margin: 0 20px;
            width: calc(100% - 40px);
            box-sizing: border-box;
        }
    </style>
</head>
<body class="luxury-dashboard">
    <div class="header">
        <h2>SENTION KartlÃ¤ggning</h2>
        <div class="navbar-links">
            <a href="{{ url_for('home', category='anstalld') }}" class="{{ 'active' if current_category == 'anstalld' else '' }}">AnstÃ¤lld</a>
            <a href="{{ url_for('home', category='grupp') }}" class="{{ 'active' if current_category == 'grupp' else '' }}">Grupp</a>
            <a href="{{ url_for('home', category='organisation') }}" class="{{ 'active' if current_category == 'organisation' else '' }}">Organisation</a>
            <a href="{{ url_for('home', category='foretagsledning') }}" class="{{ 'active' if current_category == 'foretagsledning' else '' }}">FÃ¶retagsledning</a>
            <a href="{{ url_for('home', category='managers') }}" class="{{ 'active' if current_category == 'managers' else '' }}">Managers L6</a>
            <a href="{{ url_for('home', category='supervisors') }}" class="{{ 'active' if current_category == 'supervisors' else '' }}">Supervisors AC</a>
            <a href="{{ url_for('home', category='system') }}" class="{{ 'active' if current_category == 'system' else '' }}">System</a>
        </div>
        <div class="nav-buttons">
            <a href="{{ url_for('profile') }}" class="profile-btn"><i class="bi bi-person"></i> Min profil</a>
            {% if session.role == 'admin' %}
            <a href="{{ url_for('admin_users') }}" class="admin-btn"><i class="bi bi-gear"></i> AnvÃ¤ndarhantering</a>
            {% endif %}
            <a href="{{ url_for('logout') }}" class="logout-btn"><i class="bi bi-box-arrow-right"></i> Logga ut</a>
        </div>
    </div>

    <!-- HR Row -->
    <div class="entity-row">
        <div class="entity-title">HR</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>ðŸŸ¢ Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>ðŸŸ¡ Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>ðŸ”´ HÃ¶g risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">âž• RÃ¤tt riskgrupp i rÃ¤tt tid</div>
            <div class="indicator">âž•âž• AnvÃ¤nds i Ã¶nskad utstrÃ¤ckning</div>
            <div class="indicator">âž•âž•âž• Har avsedd effekt</div>
        </div>
    </div>

    <!-- Company Health Row -->
    <div class="entity-row">
        <div class="entity-title">FÃ¶retagshÃ¤lsovÃ¥rd</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>ðŸŸ¢ Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'FÃ¶retagshÃ¤lsovÃ¥rd', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>ðŸŸ¡ Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'FÃ¶retagshÃ¤lsovÃ¥rd', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>ðŸ”´ HÃ¶g risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'FÃ¶retagshÃ¤lsovÃ¥rd', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">âž• RÃ¤tt riskgrupp i rÃ¤tt tid</div>
            <div class="indicator">âž•âž• AnvÃ¤nds i Ã¶nskad utstrÃ¤ckning</div>
            <div class="indicator">âž•âž•âž• Har avsedd effekt</div>
        </div>
    </div>

    <!-- Other Providers Row -->
    <div class="entity-row">
        <div class="entity-title">Specialistinterventioner</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>ðŸŸ¢ Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Specialistinterventioner', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>ðŸŸ¡ Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Specialistinterventioner', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>ðŸ”´ HÃ¶g risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Specialistinterventioner', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">âž• RÃ¤tt riskgrupp i rÃ¤tt tid</div>
            <div class="indicator">âž•âž• AnvÃ¤nds i Ã¶nskad utstrÃ¤ckning</div>
            <div class="indicator">âž•âž•âž• Har avsedd effekt</div>
        </div>
    </div>

    <!-- Status message and auto-save indicator -->
    <div class="container">
        <div id="auto-save-indicator" class="auto-save-indicator"></div>
        <div id="status-message" class="status-message"></div>
    </div>

    <!-- Rating selector popup -->
    <div id="rating-selector" class="rating-selector">
        <div class="rating-option" onclick="selectRating('âž•')">âž• RÃ¤tt riskgrupp i rÃ¤tt tid</div>
        <div class="rating-option" onclick="selectRating('âž•âž•')">âž•âž• AnvÃ¤nds i Ã¶nskad utstrÃ¤ckning</div>
        <div class="rating-option" onclick="selectRating('âž•âž•âž•')">âž•âž•âž• Har avsedd effekt</div>
        <div class="rating-option" onclick="selectRating('')">Ingen bedÃ¶mning</div>
    </div>
    
    <!-- Drag hint for first-time users -->
    <div id="drag-hint" class="drag-hint" style="display: none;">
        <i class="bi bi-lightbulb"></i>
        <div class="drag-hint-content">
            <span id="drag-hint-text">Du kan dra i cellen fÃ¶r att Ã¤ndra ordning pÃ¥ objekten</span>
            <div class="tip-navigation">
                <button class="tip-nav-btn" onclick="previousTip()"><i class="bi bi-chevron-left"></i></button>
                <span class="tip-counter"><span id="current-tip">1</span>/<span id="total-tips">6</span></span>
                <button class="tip-nav-btn" onclick="nextTip()"><i class="bi bi-chevron-right"></i></button>
            </div>
        </div>
        <span class="drag-hint-close" onclick="closeDragHint()">âœ•</span>
    </div>
    
    <!-- Help floating button -->
    <div id="help-floating-btn" class="help-floating-btn" onclick="showDragHint(true)">
        <i class="bi bi-lightbulb"></i>
    </div>
    
    <!-- Keyboard shortcuts modal -->
    <div id="shortcuts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal" onclick="closeShortcutsModal()">&times;</span>
            <h3>TangentbordsgenvÃ¤gar</h3>
            <table class="shortcuts-table">
                <tr>
                    <td><kbd>Enter</kbd></td>
                    <td>Avsluta redigering och spara</td>
                </tr>
                <tr>
                    <td><kbd>Esc</kbd></td>
                    <td>Avbryt redigering</td>
                </tr>
                <tr>
                    <td><kbd>Tab</kbd></td>
                    <td>GÃ¥ till nÃ¤sta objekt</td>
                </tr>
                <tr>
                    <td><kbd>Shift</kbd> + <kbd>Tab</kbd></td>
                    <td>GÃ¥ till fÃ¶regÃ¥ende objekt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>S</kbd></td>
                    <td>Spara alla Ã¤ndringar manuellt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
                    <td>LÃ¤gg till nytt objekt</td>
                </tr>
                <tr>
                    <td><kbd>Delete</kbd></td>
                    <td>Ta bort markerat objekt</td>
                </tr>
                <tr>
                    <td><kbd>?</kbd></td>
                    <td>Visa denna hjÃ¤lp</td>
                </tr>
            </table>
        </div>
    </div>
    
    <!-- Welcome tutorial modal -->
    <div id="welcome-modal" class="modal" style="display: none;">
        <div class="modal-content welcome-content">
            <span class="close-modal" onclick="closeWelcomeModal()">&times;</span>
            <h3>VÃ¤lkommen till SENTION KartlÃ¤ggning!</h3>
            <div class="welcome-steps">
                <div class="welcome-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>LÃ¤gg till objekt</h4>
                        <p>Klicka pÃ¥ <strong>+</strong> knappen i respektive kolumn fÃ¶r att lÃ¤gga till ett nytt objekt.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Redigera text</h4>
                        <p>Klicka pÃ¥ texten fÃ¶r att redigera den. Tryck <kbd>Enter</kbd> nÃ¤r du Ã¤r klar.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>SÃ¤tt betyg</h4>
                        <p>Klicka pÃ¥ betygsomrÃ¥det fÃ¶r att vÃ¤lja ett betyg frÃ¥n listan.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Ã„ndra ordning</h4>
                        <p>Dra i handtaget <i class="bi bi-grip-vertical"></i> fÃ¶r att Ã¤ndra ordning pÃ¥ objekten.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Automatisk sparning</h4>
                        <p>Alla Ã¤ndringar sparas automatiskt. Du kan se status i botten av sidan.</p>
                    </div>
                </div>
            </div>
            <div class="welcome-footer">
                <button class="welcome-btn" onclick="closeWelcomeModal()">Kom igÃ¥ng</button>
                <label class="dont-show-again">
                    <input type="checkbox" id="dont-show-welcome" onchange="updateWelcomePreference()">
                    Visa inte igen
                </label>
            </div>
        </div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = '{{ supabase_url }}';
        const supabaseKey = '{{ supabase_key }}';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
        const currentCategory = "{{ current_category }}";
        
        // Auto-save variables
        let saveTimeout = null;
        const saveDelay = 1000; // 1 second delay before saving
        
        // Current cell being rated
        let currentRatingCell = null;
        
        // Track currently editing cell
        let currentlyEditingCell = null;
        let isCurrentlySaving = false;
        
        // Track cells being edited by other users
        const cellsBeingEditedByOthers = new Map(); // Map of "entityId-riskLevel-itemId" to user ID
        
        // Generate a unique user ID for this session
        const sessionUserId = generateUUID();
        
        // Drag and drop variables
        let draggedItem = null;
        
        // Set up Supabase realtime subscription
        function setupRealtimeSubscription() {
            console.log("Setting up realtime subscription...");
            
            // Subscribe to changes in the items table
            const channel = supabaseClient.channel('items_changes')
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen for all events (INSERT, UPDATE, DELETE)
                    schema: 'public',
                        table: 'items'
                    },
                    (payload) => {
                        console.log('Change received!', payload);
                        // Only reload if we're not currently saving
                        if (!isCurrentlySaving) {
                    handleRealtimeChange(payload);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('Successfully subscribed to realtime changes!');
                    }
                });
                
            // Also subscribe to the editing status channel
            const editingChannel = supabaseClient.channel('editing_status')
                .on(
                    'broadcast',
                    { event: 'editing' },
                    (payload) => {
                        handleEditingStatus(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'rating_change' },
                    (payload) => {
                        handleRatingChange(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_deletion' },
                    (payload) => {
                        handleItemDeletion(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'new_item' },
                    (payload) => {
                        handleNewItem(payload);
                    }
                )
                .subscribe();
                
            // Set up a heartbeat to keep editing status alive
            setInterval(() => {
                if (currentlyEditingCell) {
                    // Re-broadcast our editing status every 5 seconds to keep it alive
                    broadcastEditingStatus(currentlyEditingCell, true);
                }
            }, 5000);
            
            return [channel, editingChannel];
        }
        
        // Handle realtime changes
        function handleRealtimeChange(payload) {
            console.log('Handling realtime change:', payload);
            
            // Don't reload if we're currently editing a cell
            if (currentlyEditingCell) {
                console.log('Not reloading because user is editing a cell');
                return;
            }
            
            // Don't reload if we're currently saving (to avoid duplicate updates)
            if (isCurrentlySaving) {
                console.log('Not reloading because we are currently saving');
                        return;
                    }
            
            // If this is an INSERT event, we can handle it directly without fetching all items
            if (payload.eventType === 'INSERT') {
                const newItem = payload.new;
                if (newItem && newItem.category === currentCategory) {
                    // Check if this item already exists in the DOM
                    const existingItem = document.querySelector(`.item[data-item-id="${newItem.id}"]`);
                    if (!existingItem) {
                        // Check if there's an empty item that we can use instead of creating a new one
                        const emptyItems = document.querySelectorAll(`.item[data-entity="${newItem.entity}"][data-risk="${newItem.risk_level}"]`);
                        let foundEmptyItem = false;
                        
                        for (const item of emptyItems) {
                            const textElement = item.querySelector('.item-text');
                            const ratingElement = item.querySelector('.item-rating');
                            
                            // If we find an empty item, use that instead of creating a new one
                            if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                                console.log('Found empty item, updating it with server data');
                                item.setAttribute('data-item-id', newItem.id);
                                textElement.textContent = newItem.text || '';
                                ratingElement.textContent = newItem.rating || '';
                                foundEmptyItem = true;
                    break;
            }
                        }
                        
                        // If we didn't find an empty item, create a new one
                        if (!foundEmptyItem) {
                            addItemToDOM(newItem);
                        }
                        return;
                    } else {
                        // Item exists but might need updating
                        updateItemInDOM(newItem, {
                            risk_level: existingItem.getAttribute('data-risk'),
                            entity: existingItem.getAttribute('data-entity'),
                            position: -1
                        });
                        return;
                    }
                }
            }
            
            // If this is an UPDATE event, we can handle it directly without fetching all items
            if (payload.eventType === 'UPDATE') {
                const updatedItem = payload.new;
                if (updatedItem && updatedItem.category === currentCategory) {
                    updateItemInDOM(updatedItem, payload.old);
                    return;
                }
            }
            
            // If this is a DELETE event, we can handle it directly without fetching all items
            if (payload.eventType === 'DELETE') {
                const deletedItem = payload.old;
                if (deletedItem && deletedItem.category === currentCategory) {
                    removeItemFromDOM(deletedItem);
                    return;
                }
            }
            
            // For other cases or if direct handling fails, fetch all items
            fetch(`/get_items?category=${currentCategory}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Only update if we're not currently editing or saving
                        if (!currentlyEditingCell && !isCurrentlySaving) {
                            updateItemsInDOM(data.items);
                            
                            // Show a subtle notification that content was updated
                            const autoSaveIndicator = document.getElementById('auto-save-indicator');
                            autoSaveIndicator.innerHTML = 'InnehÃ¥ll uppdaterat';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 2000);
                        }
                    } else {
                        console.error('Error fetching updated items:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error fetching updated items:', error);
                });
        }
        
        // Function to clean up empty items
        function cleanupEmptyItems() {
            // Find all items
            const items = document.querySelectorAll('.item');
            
            items.forEach(item => {
                const textElement = item.querySelector('.item-text');
                const ratingElement = item.querySelector('.item-rating');
                
                // If both text and rating are empty, remove the item
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                    // Skip if this item is currently being edited
                    if (textElement.classList.contains('cell-editing') || textElement.classList.contains('cell-editing-other')) {
                        return;
                    }
                    
                    // Remove the item
                    item.remove();
                }
            });
        }
        
        // Function to trigger auto-save with debounce
        function triggerAutoSave() {
            // Show saving indicator
            const autoSaveIndicator = document.getElementById('auto-save-indicator');
            autoSaveIndicator.innerHTML = '<span class="saving">Sparar...</span>';
            
            // Clear previous timeout
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            // Set new timeout
            saveTimeout = setTimeout(() => {
                saveDataToSupabase();
            }, saveDelay);
        }
        
        // Function to add new item to the DOM
        function addItemToDOM(item) {
            // Check if this item already exists (to avoid duplicates)
            const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
            if (existingItem) {
                console.log('Item already exists, updating instead of creating duplicate');
                // Only update if not being edited
                const textElement = existingItem.querySelector('.item-text');
                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                    updateItemInDOM(item, {
                        risk_level: existingItem.getAttribute('data-risk'),
                        entity: existingItem.getAttribute('data-entity'),
                        position: -1 // Force position update
                    });
                }
                return;
            }
            
            // Check if there's an empty item that we can use instead of creating a new one
            const emptyItems = document.querySelectorAll(`.item[data-entity="${item.entity}"][data-risk="${item.risk_level}"]`);
            let foundEmptyItem = false;
            
            for (const emptyItem of emptyItems) {
                const textElement = emptyItem.querySelector('.item-text');
                const ratingElement = emptyItem.querySelector('.item-rating');
                
                // If we find an empty item, use that instead of creating a new one
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim() && 
                    !textElement.classList.contains('cell-editing') && 
                    !textElement.classList.contains('cell-editing-other')) {
                    console.log('Found empty item, updating it with server data');
                    emptyItem.setAttribute('data-item-id', item.id);
                    textElement.textContent = item.text || '';
                    ratingElement.textContent = item.rating || '';
                    foundEmptyItem = true;
                    break;
                }
            }
            
            // If we found and updated an empty item, return
            if (foundEmptyItem) {
                return;
            }
            
            // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent === item.entity);
            
            if (entityRow) {
                const riskColumn = entityRow.querySelector(
                    item.risk_level === 'No' ? '.no-risk' :
                    item.risk_level === 'At' ? '.at-risk' :
                    '.high-risk'
                );
                
                if (riskColumn) {
                    const container = riskColumn.querySelector('.items-container');
                    
                    // Create new item
                    const itemElement = document.createElement('div');
                    itemElement.className = 'item';
                    itemElement.setAttribute('draggable', 'true');
                    itemElement.setAttribute('data-entity', item.entity);
                    itemElement.setAttribute('data-risk', item.risk_level);
                    itemElement.setAttribute('data-item-id', item.id);
                    
                    // Use empty string if rating is null, undefined, or empty
                    const ratingValue = item.rating || '';
                    
                    itemElement.innerHTML = `
                        <i class="bi bi-grip-vertical drag-handle"></i>
                        <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text || ''}</div>
                        <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                        <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                    `;
                    
                    // Add to container at the correct position
                    if (container.children.length > item.position && item.position >= 0) {
                        container.insertBefore(itemElement, container.children[item.position]);
                    } else {
                        container.appendChild(itemElement);
                    }
                    
                    // Add click handler to make text editable when clicked
                    const textElement = itemElement.querySelector('.item-text');
                    textElement.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (textElement.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (textElement.getAttribute('contenteditable') === 'false') {
                            textElement.setAttribute('contenteditable', 'true');
                            textElement.focus();
                        }
                    });
                    
                    // Initialize drag and drop for this item
                    initializeDragForItem(itemElement);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'Nytt objekt tillagt';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }
        
        // Update an existing item in the DOM
        function updateItemInDOM(item, oldItem) {
            // Find the item
            const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
            
            // Skip if this item is currently being edited
            if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                return;
            }
            
            // If the item exists, update it
                    if (existingItem) {
                // Check if the risk level has changed
                if (oldItem.risk_level !== item.risk_level || oldItem.entity !== item.entity) {
                    // Find the new container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
                    
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                        
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            
                            // Remove from old container
                            existingItem.remove();
                            
                            // Update attributes
                            existingItem.setAttribute('data-entity', item.entity);
                            existingItem.setAttribute('data-risk', item.risk_level);
                            
                            // Add to new container at the correct position
                            if (container.children.length > item.position) {
                                container.insertBefore(existingItem, container.children[item.position]);
                        } else {
                                container.appendChild(existingItem);
                            }
                            
                            // Show a notification
                            const autoSaveIndicator = document.getElementById('auto-save-indicator');
                            autoSaveIndicator.innerHTML = 'Objekt flyttat';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 2000);
                        }
                    }
                } else if (oldItem.position !== item.position && oldItem.position !== -1) {
                    // Position has changed but risk level is the same
                    const container = existingItem.parentNode;
                    
                    // Remove from current position
                    existingItem.remove();
                    
                    // Add at new position
                    if (container.children.length > item.position) {
                        container.insertBefore(existingItem, container.children[item.position]);
                    } else {
                        container.appendChild(existingItem);
                    }
                }
                
                // Update content
                const textElement = existingItem.querySelector('.item-text');
                const ratingElement = existingItem.querySelector('.item-rating');
                
                // Only update if not being edited
                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                    textElement.textContent = item.text;
                }
                
                ratingElement.textContent = item.rating || '';
            } else {
                // If the item doesn't exist, add it
                addItemToDOM(item);
            }
        }
        
        // Remove an item from the DOM
        function removeItemFromDOM(item) {
            // Find the item
            const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
            
            // Skip if this item is currently being edited
            if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                return;
            }
            
            // If the item exists, remove it
            if (existingItem) {
                existingItem.remove();
                
                // Show a notification
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Objekt borttaget';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Function to update items in the DOM without reloading the page
        function updateItemsInDOM(items) {
            console.log('Updating items in DOM:', items);
            
            // Create a map of existing items for quick lookup
            const existingItemsMap = new Map();
            document.querySelectorAll('.item').forEach(item => {
                const itemId = item.getAttribute('data-item-id');
                existingItemsMap.set(itemId, item);
            });
            
            // Create a map of updated items
            const updatedItemsMap = new Map();
            items.forEach(item => {
                if (item.category === currentCategory) {
                    updatedItemsMap.set(item.id, item);
                }
            });
            
            // First pass: Update or add items
            items.forEach(item => {
                if (item.category === currentCategory) {
                    const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
                    
                    // Skip if this item is currently being edited
                    if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                return;
            }
            
                    // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
            
            if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                
                if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            
                            if (existingItem) {
                                // Check if the item needs to be moved to a different container
                                const currentContainer = existingItem.parentNode;
                                const currentRiskLevel = existingItem.getAttribute('data-risk');
                                
                                if (currentRiskLevel !== item.risk_level) {
                                    // Item has moved to a different risk level
                                    existingItem.remove();
                                    existingItem.setAttribute('data-risk', item.risk_level);
                                    
                                    // Add to new container at the correct position
                                    if (container.children.length > item.position) {
                                        container.insertBefore(existingItem, container.children[item.position]);
                                    } else {
                                        container.appendChild(existingItem);
                                    }
                                } else if (currentContainer === container) {
                                    // Item is in the correct container, but might need reordering
                                    const currentIndex = Array.from(container.children).indexOf(existingItem);
                                    if (currentIndex !== item.position) {
                                        // Remove and reinsert at the correct position
                                        existingItem.remove();
                                        if (container.children.length > item.position) {
                                            container.insertBefore(existingItem, container.children[item.position]);
                                        } else {
                                            container.appendChild(existingItem);
                                        }
                                    }
                                }
                                
                                // Update content
                                const textElement = existingItem.querySelector('.item-text');
                                const ratingElement = existingItem.querySelector('.item-rating');
                                
                                // Only update if not being edited
                                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                                    textElement.textContent = item.text;
                                }
                                
                                ratingElement.textContent = item.rating || '';
                            } else {
                        // Create new item
                                const itemElement = document.createElement('div');
                                itemElement.className = 'item';
                                itemElement.setAttribute('draggable', 'true');
                                itemElement.setAttribute('data-entity', item.entity);
                                itemElement.setAttribute('data-risk', item.risk_level);
                                itemElement.setAttribute('data-item-id', item.id || generateUUID());
                                
                                // Use empty string if rating is null, undefined, or empty
                                const ratingValue = item.rating || '';
                                
                                itemElement.innerHTML = `
                                    <i class="bi bi-grip-vertical drag-handle"></i>
                                    <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                    <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                    <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                                `;
                                
                                // Add to container at the correct position
                                if (container.children.length > item.position) {
                                    container.insertBefore(itemElement, container.children[item.position]);
                            } else {
                                    container.appendChild(itemElement);
                                }
                                
                                // Add click handler to make text editable when clicked
                                const textElement = itemElement.querySelector('.item-text');
                                textElement.addEventListener('click', function(e) {
                                    // Prevent editing if cell is being edited by another user
                                    if (textElement.classList.contains('cell-editing-other')) {
                                        e.preventDefault();
                                        return;
                                    }
                                    
                                    if (textElement.getAttribute('contenteditable') === 'false') {
                                        textElement.setAttribute('contenteditable', 'true');
                                        textElement.focus();
                                    }
                                });
                                
                                // Initialize drag and drop for this item
                                initializeDragForItem(itemElement);
                            }
                        }
                    }
                }
            });
            
            // Second pass: Remove items that no longer exist in the updated data
            existingItemsMap.forEach((itemElement, itemId) => {
                // Skip if this item is currently being edited
                if (itemElement.querySelector('.cell-editing') || itemElement.querySelector('.cell-editing-other')) {
                    return;
                }
                
                // If the item doesn't exist in the updated data, remove it
                if (!updatedItemsMap.has(itemId)) {
                    itemElement.remove();
                }
            });
            
            // Re-apply editing indicators
            applyEditingIndicators();
        }
        
        // Handle editing status updates
        function handleEditingStatus(payload) {
            console.log('Editing status update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { userId, entityId, riskLevel, itemId, isEditing, newText } = payload.payload;
            const cellKey = `${entityId}-${riskLevel}-${itemId}`;
            
            // Find the cell
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const textCell = item.querySelector('.item-text');
                
                if (isEditing) {
                    // Another user is editing this cell
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                    
                    // Remove any click handlers that might enable editing
                    const newTextCell = textCell.cloneNode(true);
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Store in our map of cells being edited
                    cellsBeingEditedByOthers.set(cellKey, userId);
                } else {
                    // User stopped editing
                    textCell.classList.remove('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Keep it non-editable by default
                    
                    // If we received new text, update the cell content
                    if (newText !== undefined) {
                        textCell.textContent = newText;
                    }
                    
                    // Add click handler to make it editable again when clicked
                    const newTextCell = textCell.cloneNode(true);
                    newTextCell.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (newTextCell.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (newTextCell.getAttribute('contenteditable') === 'false') {
                            newTextCell.setAttribute('contenteditable', 'true');
                            newTextCell.focus();
                        }
                    });
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Remove from our map
                    cellsBeingEditedByOthers.delete(cellKey);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'InnehÃ¥ll uppdaterat';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }
        
        // Handle rating change
        function handleRatingChange(payload) {
            console.log('Rating change update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, rating } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const ratingCell = item.querySelector('.item-rating');
                
                // Update the rating
                ratingCell.textContent = rating;
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Betyg uppdaterat';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Handle item deletion
        function handleItemDeletion(payload) {
            console.log('Item deletion update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Remove the item from DOM
                item.remove();
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Objekt borttaget';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Broadcast editing status
        function broadcastEditingStatus(cell, isEditing) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Include the new text when stopping editing
            const newText = isEditing ? undefined : cell.textContent;
            
            // Broadcast editing status
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'editing',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    isEditing,
                    newText
                }
            });
        }
        
        // Apply editing indicators for cells being edited by others
        function applyEditingIndicators() {
            // Clear all existing indicators first
            document.querySelectorAll('.cell-editing-other').forEach(cell => {
                cell.classList.remove('cell-editing-other');
                cell.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                cell.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (cell.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (cell.getAttribute('contenteditable') === 'false') {
                        cell.setAttribute('contenteditable', 'true');
                        cell.focus();
                    }
                });
            });
            
            // Apply indicators for cells being edited by others
            cellsBeingEditedByOthers.forEach((userId, cellKey) => {
                const [entityId, riskLevel, itemId] = cellKey.split('-');
                
                const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
                if (item) {
                    const textCell = item.querySelector('.item-text');
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                }
            });
        }

        // Generate UUID for session
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Function to add new item
        function addNewItem(button, entity, riskLevel) {
            const column = button.closest('.risk-column');
            const container = column.querySelector('.items-container');
            
            // Check if there's already an empty item in this container
            // If so, focus on that instead of creating a new one
            const existingEmptyItems = container.querySelectorAll('.item');
            for (const existingItem of existingEmptyItems) {
                const textElement = existingItem.querySelector('.item-text');
                const ratingElement = existingItem.querySelector('.item-rating');
                
                // If we find an empty item, focus on it instead of creating a new one
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                    console.log('Found empty item, focusing on it instead of creating a new one');
                    textElement.setAttribute('contenteditable', 'true');
                    textElement.focus();
                    return;
                }
            }
            
            // Generate a unique ID for this item
            const itemId = generateUUID();
            
            // Create new item
            const item = document.createElement('div');
            item.className = 'item';
            item.setAttribute('draggable', 'true');
            item.setAttribute('data-entity', entity);
            item.setAttribute('data-risk', riskLevel);
            item.setAttribute('data-item-id', itemId);
            item.innerHTML = `
                <i class="bi bi-grip-vertical drag-handle"></i>
                <div class="item-text" contenteditable="true" data-placeholder="Skriv text hÃ¤r" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                <div class="item-rating" onclick="showRatingSelector(this)"></div>
                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
            `;
            
            // Add to container
            container.insertBefore(item, container.firstChild);
            
            // Focus on the text element
            const textElement = item.querySelector('.item-text');
            textElement.focus();
            
            // Add click handler to make text editable when clicked
            textElement.addEventListener('blur', function() {
                // After the initial edit, set contenteditable to false
                textElement.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                textElement.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (textElement.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (textElement.getAttribute('contenteditable') === 'false') {
                        textElement.setAttribute('contenteditable', 'true');
                        textElement.focus();
                    }
                });
            });
            
            // Add drag and drop event listeners
            initializeDragForItem(item);
            
            // Broadcast the new item to other users
            broadcastNewItem(entity, riskLevel, itemId);
        }

        // Broadcast new item
        function broadcastNewItem(entity, riskLevel, itemId) {
            // Broadcast new item
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'new_item',
                payload: {
                    userId: sessionUserId,
                    entityId: entity,
                    riskLevel: riskLevel,
                    itemId: itemId
                }
            });
        }

        // Function to handle cell focus
        function handleCellFocus(cell) {
            // Mark this cell as being edited
            currentlyEditingCell = cell;
            cell.classList.add('cell-editing');
            
            // Broadcast editing status
            broadcastEditingStatus(cell, true);
        }
        
        // Function to handle cell changes
        function handleCellChange(cell) {
            // Get the new text content
            const newText = cell.textContent.trim();
            
            // Remove editing indicator
            cell.classList.remove('cell-editing');
            
            // Broadcast that we stopped editing, including the new text
            broadcastEditingStatus(cell, false);
            
            // Clear currently editing cell if it's this one
            if (currentlyEditingCell === cell) {
                currentlyEditingCell = null;
            }
            
            // Only trigger auto-save if there's actual content
            if (newText) {
                triggerAutoSave();
            } else {
                // If the cell is empty after editing, consider removing it
                const item = cell.closest('.item');
                const ratingElement = item.querySelector('.item-rating');
                
                // Only remove if both text and rating are empty
                if (!ratingElement.textContent.trim()) {
                    // This is an empty item, remove it
                    item.remove();
                    // Still trigger auto-save to remove it from the database
                    triggerAutoSave();
                } else {
                    // There's a rating but no text, still save
                    triggerAutoSave();
                }
            }
        }

        // Function to show rating selector
        function showRatingSelector(cell) {
            // Store reference to current cell
            currentRatingCell = cell;
            
            // Get rating selector
            const selector = document.getElementById('rating-selector');
            
            // Position selector near the cell
            const rect = cell.getBoundingClientRect();
            selector.style.top = (rect.bottom + window.scrollY) + 'px';
            selector.style.left = rect.left + 'px';
            
            // Show selector
            selector.style.display = 'block';
            
            // Add event listener to close selector when clicking outside
            document.addEventListener('click', closeRatingSelectorOutside);
        }
        
        // Function to close rating selector when clicking outside
        function closeRatingSelectorOutside(event) {
            const selector = document.getElementById('rating-selector');
            
            // Check if click is outside the selector and not on a rating cell
            if (!selector.contains(event.target) && 
                !event.target.classList.contains('item-rating')) {
                selector.style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
            }
        }
        
        // Function to select a rating
        function selectRating(rating) {
            if (currentRatingCell) {
                // Get the previous rating value
                const previousRating = currentRatingCell.textContent;
                
                // Update the rating
                currentRatingCell.textContent = rating;
                
                // Hide selector
                document.getElementById('rating-selector').style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
                
                // Broadcast the rating change to other users
                broadcastRatingChange(currentRatingCell, rating);
                
                // Get the item and check if it has text content
                const item = currentRatingCell.closest('.item');
                const textElement = item.querySelector('.item-text');
                
                // Only trigger auto-save if there's text content or if the rating changed
                if (textElement.textContent.trim() || rating !== previousRating) {
                    triggerAutoSave();
                }
            }
        }
        
        // Broadcast rating change
        function broadcastRatingChange(cell, rating) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Broadcast rating change
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'rating_change',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    rating
                }
            });
        }
        
        // Function to delete item
        function deleteItem(button) {
            const item = button.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Remove the item from DOM
                item.remove();
            
            // Broadcast the deletion to other users
            broadcastItemDeletion(entityId, riskLevel, itemId);
            
            // Trigger auto-save
            triggerAutoSave();
        }
        
        // Broadcast item deletion
        function broadcastItemDeletion(entityId, riskLevel, itemId) {
            // Broadcast deletion
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_deletion',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId
                }
            });
        }
        
        // Function to save data to Supabase
        async function saveDataToSupabase() {
            try {
                // Set flag that we're saving
                isCurrentlySaving = true;
                
                // Clean up empty items before collecting data
                cleanupEmptyItems();
                
                const itemsData = collectItemsData();
                
                console.log('Saving items to database:', itemsData);
                
                // Use fetch to save data to the server
                const response = await fetch('/save_items', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        category: currentCategory,
                        items: itemsData
                    })
                });
                
                const data = await response.json();
                
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Error saving data');
                }
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Sparad';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
                
                // Reset saving flag
                isCurrentlySaving = false;
                
            } catch (error) {
                console.error('Error saving data:', error);
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Fel vid sparande';
                
                // Show error message
                showStatusMessage('Ett fel uppstod nÃ¤r data skulle sparas: ' + error.message, false);
                
                // Reset saving flag
                isCurrentlySaving = false;
            }
        }
        
        // Initialize drag and drop for an item
        function initializeDragForItem(item) {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('drop', handleDrop);
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            // Only allow dragging if we're not editing a cell
            if (currentlyEditingCell) {
                e.preventDefault();
                return;
            }
            
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', ''); // Required for Firefox
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            
            // Remove drag-over class from all items
            const items = document.querySelectorAll('.item');
            items.forEach(item => item.classList.remove('drag-over'));
            
            // Remove drag-over class from all containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => container.classList.remove('container-drag-over'));
            
            draggedItem = null;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            
            // Don't allow dragging if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Handle drag over items
            const item = e.target.closest('.item');
            if (item && item !== draggedItem) {
                // Remove drag-over class from all items
                const items = document.querySelectorAll('.item');
                items.forEach(i => i.classList.remove('drag-over'));
                
                // Get mouse position relative to the item
                const rect = item.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Add drag-over class to the appropriate item
                if (mouseY < threshold) {
                    item.classList.add('drag-over');
                } else {
                    // If mouse is in bottom half, add class to next item if it exists
                    const nextItem = item.nextElementSibling;
                    if (nextItem) {
                        nextItem.classList.add('drag-over');
                    } else {
                        // If there's no next item, add class to current item
                        item.classList.add('drag-over');
                    }
                }
            }
            // Handle drag over empty containers
            else {
                const container = e.target.closest('.items-container');
                if (container && (!container.contains(draggedItem) || container.children.length === 0)) {
                    // Remove drag-over class from all containers
                    const containers = document.querySelectorAll('.items-container');
                    containers.forEach(c => c.classList.remove('container-drag-over'));
                    
                    // Add drag-over class to this container
                    container.classList.add('container-drag-over');
                }
            }
            
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            // Don't allow dropping if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Handle drop on items
            const item = e.target.closest('.item');
            if (draggedItem && item && item !== draggedItem) {
                // Get mouse position relative to the item
                const rect = item.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Remove drag-over class
                item.classList.remove('drag-over');
                
                // Get the container
                const container = item.parentNode;
                
                // Insert the item based on mouse position
                if (mouseY < threshold) {
                    container.insertBefore(draggedItem, item);
                } else {
                    container.insertBefore(draggedItem, item.nextSibling);
                }
                
                // Trigger auto-save to save the new order
                triggerAutoSave();
            }
            // Handle drop on empty containers
            else {
                const container = e.target.closest('.items-container');
                if (draggedItem && container) {
                    // Remove container drag-over class
                    container.classList.remove('container-drag-over');
                    
                    // Append to the container
                    container.appendChild(draggedItem);
                    
                    // Trigger auto-save to save the new order and risk level
                    triggerAutoSave();
                }
            }
            
            return false;
        }

        // Initialize drag and drop for all containers
        function initializeDragAndDrop() {
            // Initialize items
            const items = document.querySelectorAll('.item');
            items.forEach(item => {
                initializeDragForItem(item);
            });
            
            // Initialize containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => {
                container.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dragging if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // If container is empty or doesn't contain the dragged item
                    if (draggedItem && (!this.contains(draggedItem) || this.children.length === 0)) {
                        // Remove drag-over class from all containers
                        const containers = document.querySelectorAll('.items-container');
                        containers.forEach(c => c.classList.remove('container-drag-over'));
                        
                        // Add drag-over class to this container
                        this.classList.add('container-drag-over');
                    }
                });
                
                container.addEventListener('drop', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dropping if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // If we have a dragged item and we're not dropping on another item
                    if (draggedItem && !e.target.closest('.item')) {
                        // Remove container drag-over class
                        this.classList.remove('container-drag-over');
                        
                        // Append to the container
                        this.appendChild(draggedItem);
                        
                        // Trigger auto-save to save the new order and risk level
                        triggerAutoSave();
                    }
                });
            });
        }

        // Load saved items when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const savedItems = JSON.parse('{{ saved_items_json | safe }}' || '[]');
            
            console.log('Loading saved items:', savedItems);
            
            // Create a map to track items we've already added
            const addedItems = new Set();
            
            savedItems.forEach(item => {
                if (item.category === currentCategory) {
                    // Skip if we've already added this item
                    if (item.id && addedItems.has(item.id)) {
                        console.log('Skipping duplicate item:', item.id);
                        return;
                    }
                    
                    // Find the correct container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
                    
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                        
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            const itemElement = document.createElement('div');
                            itemElement.className = 'item';
                            itemElement.setAttribute('draggable', 'true');
                            itemElement.setAttribute('data-entity', item.entity);
                            itemElement.setAttribute('data-risk', item.risk_level);
                            itemElement.setAttribute('data-item-id', item.id || generateUUID());
                            
                            // Use empty string if rating is null, undefined, or empty
                            const ratingValue = item.rating || '';
                            
                            itemElement.innerHTML = `
                                <i class="bi bi-grip-vertical drag-handle"></i>
                                <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                            `;
                            container.appendChild(itemElement);
                            
                            // Add click handler to make text editable when clicked
                            const textElement = itemElement.querySelector('.item-text');
                            textElement.addEventListener('click', function(e) {
                                // Prevent editing if cell is being edited by another user
                                if (textElement.classList.contains('cell-editing-other')) {
                                    e.preventDefault();
                    return;
                }
                
                                if (textElement.getAttribute('contenteditable') === 'false') {
                                    textElement.setAttribute('contenteditable', 'true');
                                    textElement.focus();
                                }
                            });
                            
                            // Initialize drag and drop for this item
                            initializeDragForItem(itemElement);
                            
                            // Mark this item as added
                            if (item.id) {
                                addedItems.add(item.id);
                            }
                        }
                    }
                }
            });
            
            // Set up realtime subscription
            const channels = setupRealtimeSubscription();
            
            // Clean up subscription when page unloads
            window.addEventListener('beforeunload', () => {
                console.log('Cleaning up subscription...');
                
                // Broadcast that we stopped editing any cell
                if (currentlyEditingCell) {
                    broadcastEditingStatus(currentlyEditingCell, false);
                }
                
                channels.forEach(channel => {
                    supabaseClient.removeChannel(channel);
            });
        });

            // Initialize drag and drop for all containers
            initializeDragAndDrop();
            
            // Check if this is the first visit
            if (localStorage.getItem('welcomeShown') !== 'true') {
                // Show welcome modal
                showWelcomeModal();
            } else {
                // Check if drag hint has been dismissed before
                if (localStorage.getItem('dragHintShown') === 'true') {
                    // Show help button immediately
                    showHelpButton();
                } else {
                    // Show drag hint after a short delay
                    setTimeout(showDragHint, 2000);
                }
            }
        });
        
        // Function to show welcome modal
        function showWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close welcome modal
        function closeWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'none';
            
            // Mark as shown
            localStorage.setItem('welcomeShown', 'true');
            
            // Show drag hint after closing welcome modal
            setTimeout(showDragHint, 1000);
        }
        
        // Function to update welcome preference
        function updateWelcomePreference() {
            const checkbox = document.getElementById('dont-show-welcome');
            if (checkbox.checked) {
                localStorage.setItem('welcomeShown', 'true');
                } else {
                localStorage.removeItem('welcomeShown');
            }
        }
        
        // Function to show drag hint
        function showDragHint(forceShow = false) {
            // If forceShow is true, show the hint regardless of localStorage
            if (!forceShow) {
                // Check if user has dismissed drag hint before
                if (localStorage.getItem('dragHintShown') === 'true') {
                    // Show the help button instead
                    showHelpButton();
                    return;
                }
            }
            
            // Hide help button when showing the hint
            hideHelpButton();
            
            const dragHint = document.getElementById('drag-hint');
            dragHint.style.display = 'flex';
            
            // Start rotating tips
            startRotatingTips();
            
            // Hide hint after 30 seconds if not forced
            if (!forceShow) {
                setTimeout(() => {
                    dragHint.style.display = 'none';
                    stopRotatingTips();
                    showHelpButton();
                }, 30000);
            }
        }
        
        // Function to close drag hint
        function closeDragHint() {
            const dragHint = document.getElementById('drag-hint');
            dragHint.style.display = 'none';
            
            // Stop rotating tips
            stopRotatingTips();
            
            // Remember that user has dismissed drag hint
            localStorage.setItem('dragHintShown', 'true');
            
            // Show the help button
            showHelpButton();
        }
        
        // Function to show help button
        function showHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.add('visible');
        }
        
        // Function to hide help button
        function hideHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.remove('visible');
        }
        
        // Tips array
        const tips = [
            "Du kan dra i cellen fÃ¶r att Ã¤ndra ordning pÃ¥ objekten.",
            "Klicka pÃ¥ texten fÃ¶r att redigera den.",
            "Klicka pÃ¥ betygsomrÃ¥det fÃ¶r att vÃ¤lja ett betyg.",
            "Ã„ndringar sparas automatiskt nÃ¤r du slutar redigera.",
            "AnvÃ¤nd plus-knappen fÃ¶r att lÃ¤gga till nya objekt.",
            "Dra objekt mellan kolumner fÃ¶r att Ã¤ndra risknivÃ¥.",
        ];
        
        let currentTipIndex = 0;
        let tipsInterval = null;
        
        // Function to start rotating tips
        function startRotatingTips() {
            // Set initial tip
            updateTipDisplay();
            
            // Add transition for smooth fade effect
            const tipText = document.getElementById('drag-hint-text');
            tipText.style.transition = 'opacity 0.3s ease';
            
            // Rotate through tips every 5 seconds
            tipsInterval = setInterval(nextTip, 5000);
        }
        
        // Function to stop rotating tips
        function stopRotatingTips() {
            if (tipsInterval) {
                clearInterval(tipsInterval);
                tipsInterval = null;
            }
        }
        
        // Function to update the tip display
        function updateTipDisplay() {
            const tipText = document.getElementById('drag-hint-text');
            const currentTipElement = document.getElementById('current-tip');
            const totalTipsElement = document.getElementById('total-tips');
            
            // Update tip text
            tipText.innerHTML = tips[currentTipIndex];
            
            // Update counter
            currentTipElement.textContent = currentTipIndex + 1;
            totalTipsElement.textContent = tips.length;
        }
        
        // Function to show next tip
        function nextTip() {
            const tipText = document.getElementById('drag-hint-text');
            
            // Fade out
            tipText.style.opacity = '0';
            
            // Change to next tip
            setTimeout(() => {
                currentTipIndex = (currentTipIndex + 1) % tips.length;
                updateTipDisplay();
                tipText.style.opacity = '1';
            }, 300);
        }
        
        // Function to show previous tip
        function previousTip() {
            const tipText = document.getElementById('drag-hint-text');
            
            // Fade out
            tipText.style.opacity = '0';
            
            // Change to previous tip
            setTimeout(() => {
                currentTipIndex = (currentTipIndex - 1 + tips.length) % tips.length;
                updateTipDisplay();
                tipText.style.opacity = '1';
            }, 300);
        }
        
        // Function to show shortcuts modal
        function showShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close shortcuts modal
        function closeShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'none';
        }
        
        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Show shortcuts modal when '?' is pressed
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                showShortcutsModal();
                e.preventDefault();
            }
            
            // Close modal with Escape key
            if (e.key === 'Escape' && document.getElementById('shortcuts-modal').style.display === 'flex') {
                closeShortcutsModal();
                e.preventDefault();
            }
            
            // Ctrl+S to save manually
            if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                saveDataToSupabase();
                e.preventDefault();
            }
            
            // Ctrl+N to add new item in the first column
            if (e.key === 'n' && (e.ctrlKey || e.metaKey)) {
                // Find the first add button and click it
                const firstAddButton = document.querySelector('.add-item-btn');
                if (firstAddButton) {
                    firstAddButton.click();
                }
                e.preventDefault();
            }
            
            // Delete key to remove selected item
            if (e.key === 'Delete' && currentlyEditingCell) {
                const item = currentlyEditingCell.closest('.item');
                if (item) {
                    const deleteButton = item.querySelector('.delete-btn');
                    if (deleteButton) {
                        deleteButton.click();
                    }
                }
            }
            
            // Enter key to finish editing
            if (e.key === 'Enter' && currentlyEditingCell) {
                currentlyEditingCell.blur();
                e.preventDefault();
            }
        });
        
        // Close modal when clicking outside
        window.addEventListener('click', function(e) {
            const modal = document.getElementById('shortcuts-modal');
            if (e.target === modal) {
                closeShortcutsModal();
            }
        });

        // Function to show status message
        function showStatusMessage(message, isSuccess) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = message;
            statusMessage.className = 'status-message';
            
            if (isSuccess) {
                statusMessage.classList.add('success-message');
            } else {
                statusMessage.classList.add('error-message');
            }
            
            statusMessage.style.display = 'block';
            
            // Hide message after 5 seconds
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }

        // Handle new item
        function handleNewItem(payload) {
            console.log('New item update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId } = payload.payload;
            
            // Check if this item already exists (to avoid duplicates)
            const existingItem = document.querySelector(`.item[data-item-id="${itemId}"]`);
            if (existingItem) {
                console.log('Item already exists, not creating duplicate');
                return;
            }
            
            // Also check if there's an item with the same entity and risk level that's empty
            // This helps prevent duplicates when a user is still editing a newly created item
            const emptyItems = document.querySelectorAll(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"]`);
            for (const item of emptyItems) {
                const textElement = item.querySelector('.item-text');
                const ratingElement = item.querySelector('.item-rating');
                
                // If we find an empty item, use that instead of creating a new one
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                    console.log('Found empty item, using it instead of creating a new one');
                    item.setAttribute('data-item-id', itemId);
                    return;
                }
            }
            
            // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent === entityId);
            
            if (entityRow) {
                const riskColumn = entityRow.querySelector(
                    riskLevel === 'No' ? '.no-risk' :
                    riskLevel === 'At' ? '.at-risk' :
                    '.high-risk'
                );
                
                if (riskColumn) {
                    const container = riskColumn.querySelector('.items-container');
                    
                    // Create new item
                    const itemElement = document.createElement('div');
                    itemElement.className = 'item';
                    itemElement.setAttribute('draggable', 'true');
                    itemElement.setAttribute('data-entity', entityId);
                    itemElement.setAttribute('data-risk', riskLevel);
                    itemElement.setAttribute('data-item-id', itemId);
                    
                    itemElement.innerHTML = `
                        <i class="bi bi-grip-vertical drag-handle"></i>
                        <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                        <div class="item-rating" onclick="showRatingSelector(this)"></div>
                        <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                    `;
                    
                    // Add to container at the top
                    container.insertBefore(itemElement, container.firstChild);
                    
                    // Add click handler to make text editable when clicked
                    const textElement = itemElement.querySelector('.item-text');
                    textElement.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (textElement.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (textElement.getAttribute('contenteditable') === 'false') {
                            textElement.setAttribute('contenteditable', 'true');
                            textElement.focus();
                        }
                    });
                    
                    // Initialize drag and drop for this item
                    initializeDragForItem(itemElement);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'Nytt objekt tillagt';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }

        // Function to collect all items data
        function collectItemsData() {
            const items = [];
            const processedIds = new Set(); // Track processed IDs to avoid duplicates
            
            // Get all entity rows
            const entityRows = document.querySelectorAll('.entity-row');
            
            entityRows.forEach(entityRow => {
                const entity = entityRow.querySelector('.entity-title').textContent;
                
                // Get all risk columns in this entity row
                const riskColumns = entityRow.querySelectorAll('.risk-column');
                
                riskColumns.forEach(column => {
                    // Determine risk level
                    let riskLevel = 'Unknown';
                    if (column.classList.contains('no-risk')) riskLevel = 'No';
                    if (column.classList.contains('at-risk')) riskLevel = 'At';
                    if (column.classList.contains('high-risk')) riskLevel = 'High';
                    
                    // Get all items in this column
                    const itemElements = column.querySelectorAll('.item');
                    
                    itemElements.forEach((item, index) => {
                        const text = item.querySelector('.item-text').textContent.trim();
                        const rating = item.querySelector('.item-rating').textContent.trim();
                        const itemId = item.getAttribute('data-item-id');
                        
                        // Skip if we've already processed this ID (avoid duplicates)
                        if (processedIds.has(itemId)) {
                            console.log('Skipping duplicate item ID:', itemId);
                            return;
                        }
                        
                        // Only include items that have either text or rating
                        if (text || rating) {
                            items.push({
                                id: itemId,
                                text: text,
                                entity: entity,
                                risk_level: riskLevel,
                                category: currentCategory,
                                rating: rating,
                                position: index
                            });
                            
                            // Mark this ID as processed
                            processedIds.add(itemId);
                        }
                    });
                });
            });
            
            console.log('Collected items for saving:', items);
            return items;
        }
    </script>
</body>
</html>
