<!DOCTYPE html>
<html lang="en" class="index-page">
<head>
    <title>SENTION Dashboard</title>
    <link rel="icon" type="image/png" href="https://i.postimg.cc/FRwbMSBN/SENTION-logo-Black-Transparent-BG.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Rating selector styles */
        .rating-selector {
            position: absolute;
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 10px;
            z-index: 100;
            display: none;
        }
        
        .rating-option {
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 5px;
            transition: background-color 0.2s;
        }
        
        .rating-option:hover {
            background-color: #f8f9fa;
        }

        /* Add button styles */
        .add-item-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border-radius: 6px;
            background-color: #F0EEEC;
            color: #333;
            border: none;
            cursor: pointer;
            margin: 10px auto;
        }

        .add-item-btn:hover {
            background-color: #e0dedc;
        }

        /* Item styles */
        .item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin: 5px;
            background-color: #F7F6F5;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .item:hover {
            background-color: #F0EEEC;
        }
        
        /* Drag handle styles */
        .drag-handle {
            cursor: move;
            color: #6c757d;
            padding: 5px;
            margin-right: 5px;
            opacity: 0.5;
            transition: all 0.2s;
            position: relative;
        }
        
        .drag-handle:hover {
            opacity: 1;
            transform: scale(1.2);
            color: #0d6efd;
        }
        
        .drag-handle::after {
            content: 'Dra för att ändra ordning';
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            z-index: 1000;
        }
        
        .drag-handle:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        /* Dragging styles */
        .item.dragging {
            background-color: rgba(0, 123, 255, 0.1) !important;
            opacity: 0.8;
            cursor: move;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        .item.drag-over {
            position: relative;
        }
        
        .item.drag-over::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: -2px;
            height: 4px;
            background-color: #0d6efd;
            z-index: 100;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(13, 110, 253, 0.5);
            animation: pulse 1.5s infinite;
        }

        /* Container drag-over styles */
        .items-container.container-drag-over {
            background-color: rgba(13, 110, 253, 0.05);
            border: 2px dashed #0d6efd;
            border-radius: 6px;
            padding: 10px;
            min-height: 60px;
            animation: pulse 1.5s infinite;
        }

        .item-text {
            flex-grow: 1;
            margin-right: 10px;
            min-height: 20px;
        }

        .item-text[contenteditable="true"] {
            padding: 2px;
            outline: none;
        }

        .item-rating {
            padding: 2px 5px;
            color: #666;
            min-width: 60px;
            text-align: center;
        }
        
        /* Add placeholder for empty rating */
        .item-rating:empty::before {
            content: "Klicka för betyg";
            font-style: italic;
            color: #aaa;
            font-size: 0.85em;
        }

        /* Delete button styles */
        .delete-btn {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 5px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .item:hover .delete-btn {
            opacity: 1;
        }
        
        .delete-btn:hover {
            color: #bd2130;
        }

        /* Edit mode styles */
        .editing {
            background-color: #fff;
            box-shadow: 0 0 0 2px #007bff;
        }

        .editing .delete-btn {
            opacity: 1;
        }

        /* Entity row styles */
        .entity-row {
            margin: 20px;
            width: calc(100% - 40px); /* Full width minus margins */
            max-width: 100%;
            box-sizing: border-box;
        }

        .risk-columns {
            display: flex;
            gap: 20px;
            width: 100%;
            margin-top: 10px;
        }

        .risk-column {
            flex: 1;
            border-radius: 8px;
            padding: 15px;
            min-width: 0; /* Prevents flex items from overflowing */
        }

        .risk-column.no-risk {
            background-color: rgba(40, 167, 69, 0.1); /* Light green */
        }

        .risk-column.at-risk {
            background-color: rgba(255, 193, 7, 0.1); /* Light yellow */
        }

        .risk-column.high-risk {
            background-color: rgba(220, 53, 69, 0.1); /* Light red */
        }

        .items-container {
            width: 100%;
        }

        /* Cell being edited styles */
        .cell-editing {
            background-color: rgba(255, 255, 0, 0.1) !important;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.5);
            position: relative;
        }

        .cell-editing::after {
            content: "Redigeras...";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Cell being edited by another user */
        .cell-editing-other {
            background-color: rgba(255, 0, 0, 0.1) !important;
            position: relative;
        }

        .cell-editing-other::after {
            content: "Redigeras av annan användare";
            position: absolute;
            top: -20px;
            left: 0;
            background-color: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 100;
        }

        /* Status message styles */
        .status-message {
            margin: 15px 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        
        .success-message {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        /* Auto-save indicator */
        .auto-save-indicator {
            display: inline-block;
            margin: 15px 20px;
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        /* Saving animation */
        .saving {
            display: inline-block;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        /* First-time user hint */
        .drag-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: white;
            padding: 12px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            color: #666;
            z-index: 1000;
            animation: slideIn 0.5s ease-out;
            max-width: 450px;
            width: 450px;
            min-height: 60px;
            height: 60px;
        }
        
        .drag-hint i {
            font-size: 1.2rem;
            color: #0d6efd;
        }
        
        .drag-hint-content {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        
        #drag-hint-text {
            transition: opacity 0.3s ease;
            min-height: 24px;
            display: flex;
            align-items: center;
            overflow: hidden;
            line-height: 1.4;
            flex-grow: 1;
        }
        
        .tip-navigation {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
            white-space: nowrap;
        }
        
        .tip-nav-btn {
            background: none;
            border: none;
            color: #0d6efd;
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .tip-nav-btn:hover {
            background-color: rgba(13, 110, 253, 0.1);
            transform: scale(1.1);
        }
        
        .tip-counter {
            font-size: 0.8rem;
            color: #999;
        }
        
        .drag-hint-close {
            margin-left: 10px;
            padding: 5px;
            cursor: pointer;
            color: #999;
            transition: color 0.2s;
        }
        
        .drag-hint-close:hover {
            color: #666;
        }
        
        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 500px;
            width: 90%;
            position: relative;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .close-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #333;
        }
        
        .shortcuts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .shortcuts-table tr {
            border-bottom: 1px solid #eee;
        }
        
        .shortcuts-table tr:last-child {
            border-bottom: none;
        }
        
        .shortcuts-table td {
            padding: 8px 5px;
        }
        
        .shortcuts-table td:first-child {
            width: 40%;
            text-align: right;
            padding-right: 15px;
        }
        
        kbd {
            background-color: #f7f7f7;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
            color: #333;
            display: inline-block;
            font-size: 0.85em;
            font-family: monospace;
            line-height: 1;
            padding: 2px 5px;
            margin: 0 2px;
        }
        
        /* Help button styles */
        .help-btn {
            background-color: #6c757d;
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            text-decoration: none;
            margin-left: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: background-color 0.2s;
        }
        
        .help-btn:hover {
            background-color: #5a6268;
            color: white;
        }
        
        .help-btn i {
            font-size: 1.1rem;
        }
        
        /* Welcome modal styles */
        .welcome-content {
            max-width: 600px;
            padding: 25px;
        }
        
        .welcome-steps {
            margin: 20px 0;
        }
        
        .welcome-step {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }
        
        .step-number {
            background-color: #0d6efd;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex-grow: 1;
        }
        
        .step-content h4 {
            margin: 0 0 5px 0;
            color: #333;
        }
        
        .step-content p {
            margin: 0;
            color: #666;
            line-height: 1.5;
        }
        
        .welcome-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .welcome-btn {
            background-color: #0d6efd;
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .welcome-btn:hover {
            background-color: #0b5ed7;
        }
        
        .dont-show-again {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #666;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* Help floating button */
        .help-floating-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #0d6efd;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 999;
            transition: all 0.2s;
            opacity: 0;
            visibility: hidden;
        }
        
        .help-floating-btn.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .help-floating-btn:hover {
            transform: scale(1.1);
            background-color: #0b5ed7;
        }
        
        .help-floating-btn i {
            font-size: 1.2rem;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Container styles to ensure consistent margins */
        .container {
            margin: 0 20px;
            width: calc(100% - 40px);
            box-sizing: border-box;
        }
    </style>
</head>
<body class="luxury-dashboard">
    <div class="header">
        <h2>SENTION Kartläggning</h2>
        <div class="navbar-links">
            <a href="{{ url_for('home', category='anstalld') }}" class="{{ 'active' if current_category == 'anstalld' else '' }}">Anställd</a>
            <a href="{{ url_for('home', category='grupp') }}" class="{{ 'active' if current_category == 'grupp' else '' }}">Grupp</a>
            <a href="{{ url_for('home', category='organisation') }}" class="{{ 'active' if current_category == 'organisation' else '' }}">Organisation</a>
            <a href="{{ url_for('home', category='foretagsledning') }}" class="{{ 'active' if current_category == 'foretagsledning' else '' }}">Företagsledning</a>
            <a href="{{ url_for('home', category='managers') }}" class="{{ 'active' if current_category == 'managers' else '' }}">Managers L6</a>
            <a href="{{ url_for('home', category='supervisors') }}" class="{{ 'active' if current_category == 'supervisors' else '' }}">Supervisors AC</a>
            <a href="{{ url_for('home', category='system') }}" class="{{ 'active' if current_category == 'system' else '' }}">System</a>
        </div>
        <div class="nav-buttons">
            <a href="{{ url_for('profile') }}" class="profile-btn"><i class="bi bi-person"></i> Min profil</a>
            {% if session.role == 'admin' %}
            <a href="{{ url_for('admin_users') }}" class="admin-btn"><i class="bi bi-gear"></i> Användarhantering</a>
            {% endif %}
            <a href="{{ url_for('logout') }}" class="logout-btn"><i class="bi bi-box-arrow-right"></i> Logga ut</a>
        </div>
    </div>

    <!-- HR Row -->
    <div class="entity-row">
        <div class="entity-title">HR</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>🟢 Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>🟡 Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>🔴 Hög risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'HR', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">➕ Rätt riskgrupp i rätt tid</div>
            <div class="indicator">➕➕ Används i önskad utsträckning</div>
            <div class="indicator">➕➕➕ Har avsedd effekt</div>
        </div>
    </div>

    <!-- Company Health Row -->
    <div class="entity-row">
        <div class="entity-title">Företagshälsovård</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>🟢 Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Företagshälsovård', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>🟡 Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Företagshälsovård', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>🔴 Hög risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Företagshälsovård', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">➕ Rätt riskgrupp i rätt tid</div>
            <div class="indicator">➕➕ Används i önskad utsträckning</div>
            <div class="indicator">➕➕➕ Har avsedd effekt</div>
        </div>
    </div>

    <!-- Other Providers Row -->
    <div class="entity-row">
        <div class="entity-title">Specialistinterventioner</div>
        <div class="risk-columns">
            <div class="risk-column no-risk">
                <h3>🟢 Ej risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Specialistinterventioner', 'No')">+</button>
            </div>
            <div class="risk-column at-risk">
                <h3>🟡 Risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Specialistinterventioner', 'At')">+</button>
            </div>
            <div class="risk-column high-risk">
                <h3>🔴 Hög risk</h3>
                <div class="items-container"></div>
                <button class="add-item-btn" onclick="addNewItem(this, 'Specialistinterventioner', 'High')">+</button>
            </div>
        </div>
        <div class="indicators">
            <div class="indicator">➕ Rätt riskgrupp i rätt tid</div>
            <div class="indicator">➕➕ Används i önskad utsträckning</div>
            <div class="indicator">➕➕➕ Har avsedd effekt</div>
        </div>
    </div>

    <!-- Status message and auto-save indicator -->
    <div class="container">
        <div id="auto-save-indicator" class="auto-save-indicator"></div>
        <div id="status-message" class="status-message"></div>
    </div>

    <!-- Rating selector popup -->
    <div id="rating-selector" class="rating-selector">
        <div class="rating-option" onclick="selectRating('➕')">➕ Rätt riskgrupp i rätt tid</div>
        <div class="rating-option" onclick="selectRating('➕➕')">➕➕ Används i önskad utsträckning</div>
        <div class="rating-option" onclick="selectRating('➕➕➕')">➕➕➕ Har avsedd effekt</div>
        <div class="rating-option" onclick="selectRating('')">Ingen bedömning</div>
    </div>
    
    <!-- Drag hint for first-time users -->
    <div id="drag-hint" class="drag-hint" style="display: none;">
        <i class="bi bi-lightbulb"></i>
        <div class="drag-hint-content">
            <span id="drag-hint-text">Du kan dra i cellen för att ändra ordning på objekten</span>
            <div class="tip-navigation">
                <button class="tip-nav-btn" onclick="previousTip()"><i class="bi bi-chevron-left"></i></button>
                <span class="tip-counter"><span id="current-tip">1</span>/<span id="total-tips">6</span></span>
                <button class="tip-nav-btn" onclick="nextTip()"><i class="bi bi-chevron-right"></i></button>
            </div>
        </div>
        <span class="drag-hint-close" onclick="closeDragHint()">✕</span>
    </div>
    
    <!-- Help floating button -->
    <div id="help-floating-btn" class="help-floating-btn" onclick="showDragHint(true)">
        <i class="bi bi-lightbulb"></i>
    </div>
    
    <!-- Keyboard shortcuts modal -->
    <div id="shortcuts-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-modal" onclick="closeShortcutsModal()">&times;</span>
            <h3>Tangentbordsgenvägar</h3>
            <table class="shortcuts-table">
                <tr>
                    <td><kbd>Enter</kbd></td>
                    <td>Avsluta redigering och spara</td>
                </tr>
                <tr>
                    <td><kbd>Esc</kbd></td>
                    <td>Avbryt redigering</td>
                </tr>
                <tr>
                    <td><kbd>Tab</kbd></td>
                    <td>Gå till nästa objekt</td>
                </tr>
                <tr>
                    <td><kbd>Shift</kbd> + <kbd>Tab</kbd></td>
                    <td>Gå till föregående objekt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>S</kbd></td>
                    <td>Spara alla ändringar manuellt</td>
                </tr>
                <tr>
                    <td><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
                    <td>Lägg till nytt objekt</td>
                </tr>
                <tr>
                    <td><kbd>Delete</kbd></td>
                    <td>Ta bort markerat objekt</td>
                </tr>
                <tr>
                    <td><kbd>?</kbd></td>
                    <td>Visa denna hjälp</td>
                </tr>
            </table>
        </div>
    </div>
    
    <!-- Welcome tutorial modal -->
    <div id="welcome-modal" class="modal" style="display: none;">
        <div class="modal-content welcome-content">
            <span class="close-modal" onclick="closeWelcomeModal()">&times;</span>
            <h3>Välkommen till SENTION Kartläggning!</h3>
            <div class="welcome-steps">
                <div class="welcome-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Lägg till objekt</h4>
                        <p>Klicka på <strong>+</strong> knappen i respektive kolumn för att lägga till ett nytt objekt.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Redigera text</h4>
                        <p>Klicka på texten för att redigera den. Tryck <kbd>Enter</kbd> när du är klar.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Sätt betyg</h4>
                        <p>Klicka på betygsområdet för att välja ett betyg från listan.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Ändra ordning</h4>
                        <p>Dra i handtaget <i class="bi bi-grip-vertical"></i> för att ändra ordning på objekten.</p>
                    </div>
                </div>
                <div class="welcome-step">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <h4>Automatisk sparning</h4>
                        <p>Alla ändringar sparas automatiskt. Du kan se status i botten av sidan.</p>
                    </div>
                </div>
            </div>
            <div class="welcome-footer">
                <button class="welcome-btn" onclick="closeWelcomeModal()">Kom igång</button>
                <label class="dont-show-again">
                    <input type="checkbox" id="dont-show-welcome" onchange="updateWelcomePreference()">
                    Visa inte igen
                </label>
            </div>
        </div>
    </div>

    <script>
        // Initialize Supabase client
        const supabaseUrl = '{{ supabase_url }}';
        const supabaseKey = '{{ supabase_key }}';
        const supabaseClient = supabase.createClient(supabaseUrl, supabaseKey);
        const currentCategory = "{{ current_category }}";
        
        // Auto-save variables
        let saveTimeout = null;
        const saveDelay = 1000; // 1 second delay before saving
        
        // Current cell being rated
        let currentRatingCell = null;
        
        // Track currently editing cell
        let currentlyEditingCell = null;
        let isCurrentlySaving = false;
        
        // Track cells being edited by other users
        const cellsBeingEditedByOthers = new Map(); // Map of "entityId-riskLevel-itemId" to user ID
        
        // Generate a unique user ID for this session
        const sessionUserId = generateUUID();
        
        // Drag and drop variables
        let draggedItem = null;
        
        // Set up Supabase realtime subscription
        function setupRealtimeSubscription() {
            console.log("Setting up realtime subscription...");
            
            // Subscribe to changes in the items table
            const channel = supabaseClient.channel('items_changes')
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen for all events (INSERT, UPDATE, DELETE)
                    schema: 'public',
                        table: 'items'
                    },
                    (payload) => {
                        console.log('Change received!', payload);
                        // Only reload if we're not currently saving
                        if (!isCurrentlySaving) {
                    handleRealtimeChange(payload);
                        }
                    }
                )
                .subscribe((status) => {
                    console.log('Subscription status:', status);
                    if (status === 'SUBSCRIBED') {
                        console.log('Successfully subscribed to realtime changes!');
                    }
                });
                
            // Also subscribe to the editing status channel
            const editingChannel = supabaseClient.channel('editing_status')
                .on(
                    'broadcast',
                    { event: 'editing' },
                    (payload) => {
                        handleEditingStatus(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'rating_change' },
                    (payload) => {
                        handleRatingChange(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'item_deletion' },
                    (payload) => {
                        handleItemDeletion(payload);
                    }
                )
                .on(
                    'broadcast',
                    { event: 'new_item' },
                    (payload) => {
                        handleNewItem(payload);
                    }
                )
                .subscribe();
                
            // Set up a heartbeat to keep editing status alive
            setInterval(() => {
                if (currentlyEditingCell) {
                    // Re-broadcast our editing status every 5 seconds to keep it alive
                    broadcastEditingStatus(currentlyEditingCell, true);
                }
            }, 5000);
            
            return [channel, editingChannel];
        }
        
        // Handle realtime changes
        function handleRealtimeChange(payload) {
            console.log('Handling realtime change:', payload);
            
            // Don't reload if we're currently editing a cell
            if (currentlyEditingCell) {
                console.log('Not reloading because user is editing a cell');
                return;
            }
            
            // Don't reload if we're currently saving (to avoid duplicate updates)
            if (isCurrentlySaving) {
                console.log('Not reloading because we are currently saving');
                        return;
                    }
            
            // If this is an INSERT event, we can handle it directly without fetching all items
            if (payload.eventType === 'INSERT') {
                const newItem = payload.new;
                if (newItem && newItem.category === currentCategory) {
                    // Check if this item already exists in the DOM
                    const existingItem = document.querySelector(`.item[data-item-id="${newItem.id}"]`);
                    if (!existingItem) {
                        // Check if there's an empty item that we can use instead of creating a new one
                        const emptyItems = document.querySelectorAll(`.item[data-entity="${newItem.entity}"][data-risk="${newItem.risk_level}"]`);
                        let foundEmptyItem = false;
                        
                        for (const item of emptyItems) {
                            const textElement = item.querySelector('.item-text');
                            const ratingElement = item.querySelector('.item-rating');
                            
                            // If we find an empty item, use that instead of creating a new one
                            if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                                console.log('Found empty item, updating it with server data');
                                item.setAttribute('data-item-id', newItem.id);
                                textElement.textContent = newItem.text || '';
                                ratingElement.textContent = newItem.rating || '';
                                foundEmptyItem = true;
                    break;
            }
                        }
                        
                        // If we didn't find an empty item, create a new one
                        if (!foundEmptyItem) {
                            addItemToDOM(newItem);
                        }
                        return;
                    } else {
                        // Item exists but might need updating
                        updateItemInDOM(newItem, {
                            risk_level: existingItem.getAttribute('data-risk'),
                            entity: existingItem.getAttribute('data-entity'),
                            position: -1
                        });
                        return;
                    }
                }
            }
            
            // If this is an UPDATE event, we can handle it directly without fetching all items
            if (payload.eventType === 'UPDATE') {
                const updatedItem = payload.new;
                if (updatedItem && updatedItem.category === currentCategory) {
                    updateItemInDOM(updatedItem, payload.old);
                    return;
                }
            }
            
            // If this is a DELETE event, we can handle it directly without fetching all items
            if (payload.eventType === 'DELETE') {
                const deletedItem = payload.old;
                if (deletedItem && deletedItem.category === currentCategory) {
                    removeItemFromDOM(deletedItem);
                    return;
                }
            }
            
            // For other cases or if direct handling fails, fetch all items
            fetch(`/get_items?category=${currentCategory}`)
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Only update if we're not currently editing or saving
                        if (!currentlyEditingCell && !isCurrentlySaving) {
                            updateItemsInDOM(data.items);
                            
                            // Show a subtle notification that content was updated
                            const autoSaveIndicator = document.getElementById('auto-save-indicator');
                            autoSaveIndicator.innerHTML = 'Innehåll uppdaterat';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 2000);
                        }
                    } else {
                        console.error('Error fetching updated items:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error fetching updated items:', error);
                });
        }
        
        // Function to clean up empty items
        function cleanupEmptyItems() {
            // Find all items
            const items = document.querySelectorAll('.item');
            
            items.forEach(item => {
                const textElement = item.querySelector('.item-text');
                const ratingElement = item.querySelector('.item-rating');
                
                // If both text and rating are empty, remove the item
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                    // Skip if this item is currently being edited
                    if (textElement.classList.contains('cell-editing') || textElement.classList.contains('cell-editing-other')) {
                        return;
                    }
                    
                    // Remove the item
                    item.remove();
                }
            });
        }
        
        // Function to trigger auto-save with debounce
        function triggerAutoSave() {
            // Show saving indicator
            const autoSaveIndicator = document.getElementById('auto-save-indicator');
            autoSaveIndicator.innerHTML = '<span class="saving">Sparar...</span>';
            
            // Clear previous timeout
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            // Set new timeout
            saveTimeout = setTimeout(() => {
                saveDataToSupabase();
            }, saveDelay);
        }
        
        // Function to add new item to the DOM
        function addItemToDOM(item) {
            // Check if this item already exists (to avoid duplicates)
            const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
            if (existingItem) {
                console.log('Item already exists, updating instead of creating duplicate');
                // Only update if not being edited
                const textElement = existingItem.querySelector('.item-text');
                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                    updateItemInDOM(item, {
                        risk_level: existingItem.getAttribute('data-risk'),
                        entity: existingItem.getAttribute('data-entity'),
                        position: -1 // Force position update
                    });
                }
                return;
            }
            
            // Check if there's an empty item that we can use instead of creating a new one
            const emptyItems = document.querySelectorAll(`.item[data-entity="${item.entity}"][data-risk="${item.risk_level}"]`);
            let foundEmptyItem = false;
            
            for (const emptyItem of emptyItems) {
                const textElement = emptyItem.querySelector('.item-text');
                const ratingElement = emptyItem.querySelector('.item-rating');
                
                // If we find an empty item, use that instead of creating a new one
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim() && 
                    !textElement.classList.contains('cell-editing') && 
                    !textElement.classList.contains('cell-editing-other')) {
                    console.log('Found empty item, updating it with server data');
                    emptyItem.setAttribute('data-item-id', item.id);
                    textElement.textContent = item.text || '';
                    ratingElement.textContent = item.rating || '';
                    foundEmptyItem = true;
                    break;
                }
            }
            
            // If we found and updated an empty item, return
            if (foundEmptyItem) {
                return;
            }
            
            // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent === item.entity);
            
            if (entityRow) {
                const riskColumn = entityRow.querySelector(
                    item.risk_level === 'No' ? '.no-risk' :
                    item.risk_level === 'At' ? '.at-risk' :
                    '.high-risk'
                );
                
                if (riskColumn) {
                    const container = riskColumn.querySelector('.items-container');
                    
                    // Create new item
                    const itemElement = document.createElement('div');
                    itemElement.className = 'item';
                    itemElement.setAttribute('draggable', 'true');
                    itemElement.setAttribute('data-entity', item.entity);
                    itemElement.setAttribute('data-risk', item.risk_level);
                    itemElement.setAttribute('data-item-id', item.id);
                    
                    // Use empty string if rating is null, undefined, or empty
                    const ratingValue = item.rating || '';
                    
                    itemElement.innerHTML = `
                        <i class="bi bi-grip-vertical drag-handle"></i>
                        <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text || ''}</div>
                        <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                        <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                    `;
                    
                    // Add to container at the correct position
                    if (container.children.length > item.position && item.position >= 0) {
                        container.insertBefore(itemElement, container.children[item.position]);
                    } else {
                        container.appendChild(itemElement);
                    }
                    
                    // Add click handler to make text editable when clicked
                    const textElement = itemElement.querySelector('.item-text');
                    textElement.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (textElement.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (textElement.getAttribute('contenteditable') === 'false') {
                            textElement.setAttribute('contenteditable', 'true');
                            textElement.focus();
                        }
                    });
                    
                    // Initialize drag and drop for this item
                    initializeDragForItem(itemElement);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'Nytt objekt tillagt';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }
        
        // Update an existing item in the DOM
        function updateItemInDOM(item, oldItem) {
            // Find the item
            const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
            
            // Skip if this item is currently being edited
            if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                return;
            }
            
            // If the item exists, update it
                    if (existingItem) {
                // Check if the risk level has changed
                if (oldItem.risk_level !== item.risk_level || oldItem.entity !== item.entity) {
                    // Find the new container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
                    
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                        
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            
                            // Remove from old container
                            existingItem.remove();
                            
                            // Update attributes
                            existingItem.setAttribute('data-entity', item.entity);
                            existingItem.setAttribute('data-risk', item.risk_level);
                            
                            // Add to new container at the correct position
                            if (container.children.length > item.position) {
                                container.insertBefore(existingItem, container.children[item.position]);
                        } else {
                                container.appendChild(existingItem);
                            }
                            
                            // Show a notification
                            const autoSaveIndicator = document.getElementById('auto-save-indicator');
                            autoSaveIndicator.innerHTML = 'Objekt flyttat';
                            setTimeout(() => {
                                autoSaveIndicator.innerHTML = '';
                            }, 2000);
                        }
                    }
                } else if (oldItem.position !== item.position && oldItem.position !== -1) {
                    // Position has changed but risk level is the same
                    const container = existingItem.parentNode;
                    
                    // Remove from current position
                    existingItem.remove();
                    
                    // Add at new position
                    if (container.children.length > item.position) {
                        container.insertBefore(existingItem, container.children[item.position]);
                    } else {
                        container.appendChild(existingItem);
                    }
                }
                
                // Update content
                const textElement = existingItem.querySelector('.item-text');
                const ratingElement = existingItem.querySelector('.item-rating');
                
                // Only update if not being edited
                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                    textElement.textContent = item.text;
                }
                
                ratingElement.textContent = item.rating || '';
            } else {
                // If the item doesn't exist, add it
                addItemToDOM(item);
            }
        }
        
        // Remove an item from the DOM
        function removeItemFromDOM(item) {
            // Find the item
            const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
            
            // Skip if this item is currently being edited
            if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                return;
            }
            
            // If the item exists, remove it
            if (existingItem) {
                existingItem.remove();
                
                // Show a notification
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Objekt borttaget';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Function to update items in the DOM without reloading the page
        function updateItemsInDOM(items) {
            console.log('Updating items in DOM:', items);
            
            // Create a map of existing items for quick lookup
            const existingItemsMap = new Map();
            document.querySelectorAll('.item').forEach(item => {
                const itemId = item.getAttribute('data-item-id');
                existingItemsMap.set(itemId, item);
            });
            
            // Create a map of updated items
            const updatedItemsMap = new Map();
            items.forEach(item => {
                if (item.category === currentCategory) {
                    updatedItemsMap.set(item.id, item);
                }
            });
            
            // First pass: Update or add items
            items.forEach(item => {
                if (item.category === currentCategory) {
                    const existingItem = document.querySelector(`.item[data-item-id="${item.id}"]`);
                    
                    // Skip if this item is currently being edited
                    if (existingItem && (existingItem.querySelector('.cell-editing') || existingItem.querySelector('.cell-editing-other'))) {
                return;
            }
            
                    // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
            
            if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                
                if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            
                            if (existingItem) {
                                // Check if the item needs to be moved to a different container
                                const currentContainer = existingItem.parentNode;
                                const currentRiskLevel = existingItem.getAttribute('data-risk');
                                
                                if (currentRiskLevel !== item.risk_level) {
                                    // Item has moved to a different risk level
                                    existingItem.remove();
                                    existingItem.setAttribute('data-risk', item.risk_level);
                                    
                                    // Add to new container at the correct position
                                    if (container.children.length > item.position) {
                                        container.insertBefore(existingItem, container.children[item.position]);
                                    } else {
                                        container.appendChild(existingItem);
                                    }
                                } else if (currentContainer === container) {
                                    // Item is in the correct container, but might need reordering
                                    const currentIndex = Array.from(container.children).indexOf(existingItem);
                                    if (currentIndex !== item.position) {
                                        // Remove and reinsert at the correct position
                                        existingItem.remove();
                                        if (container.children.length > item.position) {
                                            container.insertBefore(existingItem, container.children[item.position]);
                                        } else {
                                            container.appendChild(existingItem);
                                        }
                                    }
                                }
                                
                                // Update content
                                const textElement = existingItem.querySelector('.item-text');
                                const ratingElement = existingItem.querySelector('.item-rating');
                                
                                // Only update if not being edited
                                if (!textElement.classList.contains('cell-editing') && !textElement.classList.contains('cell-editing-other')) {
                                    textElement.textContent = item.text;
                                }
                                
                                ratingElement.textContent = item.rating || '';
                            } else {
                        // Create new item
                                const itemElement = document.createElement('div');
                                itemElement.className = 'item';
                                itemElement.setAttribute('draggable', 'true');
                                itemElement.setAttribute('data-entity', item.entity);
                                itemElement.setAttribute('data-risk', item.risk_level);
                                itemElement.setAttribute('data-item-id', item.id || generateUUID());
                                
                                // Use empty string if rating is null, undefined, or empty
                                const ratingValue = item.rating || '';
                                
                                itemElement.innerHTML = `
                                    <i class="bi bi-grip-vertical drag-handle"></i>
                                    <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                    <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                    <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                                `;
                                
                                // Add to container at the correct position
                                if (container.children.length > item.position) {
                                    container.insertBefore(itemElement, container.children[item.position]);
                            } else {
                                    container.appendChild(itemElement);
                                }
                                
                                // Add click handler to make text editable when clicked
                                const textElement = itemElement.querySelector('.item-text');
                                textElement.addEventListener('click', function(e) {
                                    // Prevent editing if cell is being edited by another user
                                    if (textElement.classList.contains('cell-editing-other')) {
                                        e.preventDefault();
                                        return;
                                    }
                                    
                                    if (textElement.getAttribute('contenteditable') === 'false') {
                                        textElement.setAttribute('contenteditable', 'true');
                                        textElement.focus();
                                    }
                                });
                                
                                // Initialize drag and drop for this item
                                initializeDragForItem(itemElement);
                            }
                        }
                    }
                }
            });
            
            // Second pass: Remove items that no longer exist in the updated data
            existingItemsMap.forEach((itemElement, itemId) => {
                // Skip if this item is currently being edited
                if (itemElement.querySelector('.cell-editing') || itemElement.querySelector('.cell-editing-other')) {
                    return;
                }
                
                // If the item doesn't exist in the updated data, remove it
                if (!updatedItemsMap.has(itemId)) {
                    itemElement.remove();
                }
            });
            
            // Re-apply editing indicators
            applyEditingIndicators();
        }
        
        // Handle editing status updates
        function handleEditingStatus(payload) {
            console.log('Editing status update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { userId, entityId, riskLevel, itemId, isEditing, newText } = payload.payload;
            const cellKey = `${entityId}-${riskLevel}-${itemId}`;
            
            // Find the cell
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const textCell = item.querySelector('.item-text');
                
                if (isEditing) {
                    // Another user is editing this cell
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                    
                    // Remove any click handlers that might enable editing
                    const newTextCell = textCell.cloneNode(true);
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Store in our map of cells being edited
                    cellsBeingEditedByOthers.set(cellKey, userId);
                } else {
                    // User stopped editing
                    textCell.classList.remove('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Keep it non-editable by default
                    
                    // If we received new text, update the cell content
                    if (newText !== undefined) {
                        textCell.textContent = newText;
                    }
                    
                    // Add click handler to make it editable again when clicked
                    const newTextCell = textCell.cloneNode(true);
                    newTextCell.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (newTextCell.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (newTextCell.getAttribute('contenteditable') === 'false') {
                            newTextCell.setAttribute('contenteditable', 'true');
                            newTextCell.focus();
                        }
                    });
                    textCell.parentNode.replaceChild(newTextCell, textCell);
                    
                    // Remove from our map
                    cellsBeingEditedByOthers.delete(cellKey);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'Innehåll uppdaterat';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }
        
        // Handle rating change
        function handleRatingChange(payload) {
            console.log('Rating change update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId, rating } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                const ratingCell = item.querySelector('.item-rating');
                
                // Update the rating
                ratingCell.textContent = rating;
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Betyg uppdaterat';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Handle item deletion
        function handleItemDeletion(payload) {
            console.log('Item deletion update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId } = payload.payload;
            
            // Find the item
            const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
            if (item) {
                // Remove the item from DOM
                item.remove();
                
                // Show a subtle notification that content was updated
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Objekt borttaget';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
            }
        }
        
        // Broadcast editing status
        function broadcastEditingStatus(cell, isEditing) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Include the new text when stopping editing
            const newText = isEditing ? undefined : cell.textContent;
            
            // Broadcast editing status
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'editing',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    isEditing,
                    newText
                }
            });
        }
        
        // Apply editing indicators for cells being edited by others
        function applyEditingIndicators() {
            // Clear all existing indicators first
            document.querySelectorAll('.cell-editing-other').forEach(cell => {
                cell.classList.remove('cell-editing-other');
                cell.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                cell.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (cell.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (cell.getAttribute('contenteditable') === 'false') {
                        cell.setAttribute('contenteditable', 'true');
                        cell.focus();
                    }
                });
            });
            
            // Apply indicators for cells being edited by others
            cellsBeingEditedByOthers.forEach((userId, cellKey) => {
                const [entityId, riskLevel, itemId] = cellKey.split('-');
                
                const item = document.querySelector(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"][data-item-id="${itemId}"]`);
                if (item) {
                    const textCell = item.querySelector('.item-text');
                    textCell.classList.add('cell-editing-other');
                    textCell.setAttribute('contenteditable', 'false'); // Prevent editing
                }
            });
        }

        // Generate UUID for session
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Function to add new item
        function addNewItem(button, entity, riskLevel) {
            const column = button.closest('.risk-column');
            const container = column.querySelector('.items-container');
            
            // Check if there's already an empty item in this container
            // If so, focus on that instead of creating a new one
            const existingEmptyItems = container.querySelectorAll('.item');
            for (const existingItem of existingEmptyItems) {
                const textElement = existingItem.querySelector('.item-text');
                const ratingElement = existingItem.querySelector('.item-rating');
                
                // If we find an empty item, focus on it instead of creating a new one
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                    console.log('Found empty item, focusing on it instead of creating a new one');
                    textElement.setAttribute('contenteditable', 'true');
                    textElement.focus();
                    return;
                }
            }
            
            // Generate a unique ID for this item
            const itemId = generateUUID();
            
            // Create new item
            const item = document.createElement('div');
            item.className = 'item';
            item.setAttribute('draggable', 'true');
            item.setAttribute('data-entity', entity);
            item.setAttribute('data-risk', riskLevel);
            item.setAttribute('data-item-id', itemId);
            item.innerHTML = `
                <i class="bi bi-grip-vertical drag-handle"></i>
                <div class="item-text" contenteditable="true" data-placeholder="Skriv text här" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                <div class="item-rating" onclick="showRatingSelector(this)"></div>
                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
            `;
            
            // Add to container
            container.insertBefore(item, container.firstChild);
            
            // Focus on the text element
            const textElement = item.querySelector('.item-text');
            textElement.focus();
            
            // Add click handler to make text editable when clicked
            textElement.addEventListener('blur', function() {
                // After the initial edit, set contenteditable to false
                textElement.setAttribute('contenteditable', 'false');
                
                // Add click handler to make it editable again when clicked
                textElement.addEventListener('click', function(e) {
                    // Prevent editing if cell is being edited by another user
                    if (textElement.classList.contains('cell-editing-other')) {
                        e.preventDefault();
                        return;
                    }
                    
                    if (textElement.getAttribute('contenteditable') === 'false') {
                        textElement.setAttribute('contenteditable', 'true');
                        textElement.focus();
                    }
                });
            });
            
            // Add drag and drop event listeners
            initializeDragForItem(item);
            
            // Broadcast the new item to other users
            broadcastNewItem(entity, riskLevel, itemId);
        }

        // Broadcast new item
        function broadcastNewItem(entity, riskLevel, itemId) {
            // Broadcast new item
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'new_item',
                payload: {
                    userId: sessionUserId,
                    entityId: entity,
                    riskLevel: riskLevel,
                    itemId: itemId
                }
            });
        }

        // Function to handle cell focus
        function handleCellFocus(cell) {
            // Mark this cell as being edited
            currentlyEditingCell = cell;
            cell.classList.add('cell-editing');
            
            // Broadcast editing status
            broadcastEditingStatus(cell, true);
        }
        
        // Function to handle cell changes
        function handleCellChange(cell) {
            // Get the new text content
            const newText = cell.textContent.trim();
            
            // Remove editing indicator
            cell.classList.remove('cell-editing');
            
            // Broadcast that we stopped editing, including the new text
            broadcastEditingStatus(cell, false);
            
            // Clear currently editing cell if it's this one
            if (currentlyEditingCell === cell) {
                currentlyEditingCell = null;
            }
            
            // Only trigger auto-save if there's actual content
            if (newText) {
                triggerAutoSave();
            } else {
                // If the cell is empty after editing, consider removing it
                const item = cell.closest('.item');
                const ratingElement = item.querySelector('.item-rating');
                
                // Only remove if both text and rating are empty
                if (!ratingElement.textContent.trim()) {
                    // This is an empty item, remove it
                    item.remove();
                    // Still trigger auto-save to remove it from the database
                    triggerAutoSave();
                } else {
                    // There's a rating but no text, still save
                    triggerAutoSave();
                }
            }
        }

        // Function to show rating selector
        function showRatingSelector(cell) {
            // Store reference to current cell
            currentRatingCell = cell;
            
            // Get rating selector
            const selector = document.getElementById('rating-selector');
            
            // Position selector near the cell
            const rect = cell.getBoundingClientRect();
            selector.style.top = (rect.bottom + window.scrollY) + 'px';
            selector.style.left = rect.left + 'px';
            
            // Show selector
            selector.style.display = 'block';
            
            // Add event listener to close selector when clicking outside
            document.addEventListener('click', closeRatingSelectorOutside);
        }
        
        // Function to close rating selector when clicking outside
        function closeRatingSelectorOutside(event) {
            const selector = document.getElementById('rating-selector');
            
            // Check if click is outside the selector and not on a rating cell
            if (!selector.contains(event.target) && 
                !event.target.classList.contains('item-rating')) {
                selector.style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
            }
        }
        
        // Function to select a rating
        function selectRating(rating) {
            if (currentRatingCell) {
                // Get the previous rating value
                const previousRating = currentRatingCell.textContent;
                
                // Update the rating
                currentRatingCell.textContent = rating;
                
                // Hide selector
                document.getElementById('rating-selector').style.display = 'none';
                document.removeEventListener('click', closeRatingSelectorOutside);
                
                // Broadcast the rating change to other users
                broadcastRatingChange(currentRatingCell, rating);
                
                // Get the item and check if it has text content
                const item = currentRatingCell.closest('.item');
                const textElement = item.querySelector('.item-text');
                
                // Only trigger auto-save if there's text content or if the rating changed
                if (textElement.textContent.trim() || rating !== previousRating) {
                    triggerAutoSave();
                }
            }
        }
        
        // Broadcast rating change
        function broadcastRatingChange(cell, rating) {
            // Find item and get its data attributes
            const item = cell.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Broadcast rating change
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'rating_change',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId,
                    rating
                }
            });
        }
        
        // Function to delete item
        function deleteItem(button) {
            const item = button.closest('.item');
            const entityId = item.getAttribute('data-entity');
            const riskLevel = item.getAttribute('data-risk');
            const itemId = item.getAttribute('data-item-id');
            
            // Remove the item from DOM
                item.remove();
            
            // Broadcast the deletion to other users
            broadcastItemDeletion(entityId, riskLevel, itemId);
            
            // Trigger auto-save
            triggerAutoSave();
        }
        
        // Broadcast item deletion
        function broadcastItemDeletion(entityId, riskLevel, itemId) {
            // Broadcast deletion
            supabaseClient.channel('editing_status').send({
                type: 'broadcast',
                event: 'item_deletion',
                payload: {
                    userId: sessionUserId,
                    entityId,
                    riskLevel,
                    itemId
                }
            });
        }
        
        // Function to save data to Supabase
        async function saveDataToSupabase() {
            try {
                // Set flag that we're saving
                isCurrentlySaving = true;
                
                // Clean up empty items before collecting data
                cleanupEmptyItems();
                
                const itemsData = collectItemsData();
                
                console.log('Saving items to database:', itemsData);
                
                // Use fetch to save data to the server
                const response = await fetch('/save_items', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        category: currentCategory,
                        items: itemsData
                    })
                });
                
                const data = await response.json();
                
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Error saving data');
                }
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Sparad';
                setTimeout(() => {
                    autoSaveIndicator.innerHTML = '';
                }, 2000);
                
                // Reset saving flag
                isCurrentlySaving = false;
                
            } catch (error) {
                console.error('Error saving data:', error);
                
                // Update auto-save indicator
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                autoSaveIndicator.innerHTML = 'Fel vid sparande';
                
                // Show error message
                showStatusMessage('Ett fel uppstod när data skulle sparas: ' + error.message, false);
                
                // Reset saving flag
                isCurrentlySaving = false;
            }
        }
        
        // Initialize drag and drop for an item
        function initializeDragForItem(item) {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('drop', handleDrop);
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            // Only allow dragging if we're not editing a cell
            if (currentlyEditingCell) {
                e.preventDefault();
                return;
            }
            
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', ''); // Required for Firefox
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            
            // Remove drag-over class from all items
            const items = document.querySelectorAll('.item');
            items.forEach(item => item.classList.remove('drag-over'));
            
            // Remove drag-over class from all containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => container.classList.remove('container-drag-over'));
            
            draggedItem = null;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            
            // Don't allow dragging if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Handle drag over items
            const item = e.target.closest('.item');
            if (item && item !== draggedItem) {
                // Remove drag-over class from all items
                const items = document.querySelectorAll('.item');
                items.forEach(i => i.classList.remove('drag-over'));
                
                // Get mouse position relative to the item
                const rect = item.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Add drag-over class to the appropriate item
                if (mouseY < threshold) {
                    item.classList.add('drag-over');
                } else {
                    // If mouse is in bottom half, add class to next item if it exists
                    const nextItem = item.nextElementSibling;
                    if (nextItem) {
                        nextItem.classList.add('drag-over');
                    } else {
                        // If there's no next item, add class to current item
                        item.classList.add('drag-over');
                    }
                }
            }
            // Handle drag over empty containers
            else {
                const container = e.target.closest('.items-container');
                if (container && (!container.contains(draggedItem) || container.children.length === 0)) {
                    // Remove drag-over class from all containers
                    const containers = document.querySelectorAll('.items-container');
                    containers.forEach(c => c.classList.remove('container-drag-over'));
                    
                    // Add drag-over class to this container
                    container.classList.add('container-drag-over');
                }
            }
            
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            // Don't allow dropping if any cell is being edited
            if (currentlyEditingCell) {
                return;
            }
            
            // Handle drop on items
            const item = e.target.closest('.item');
            if (draggedItem && item && item !== draggedItem) {
                // Get mouse position relative to the item
                const rect = item.getBoundingClientRect();
                const mouseY = e.clientY;
                const threshold = rect.top + (rect.height / 2);
                
                // Remove drag-over class
                item.classList.remove('drag-over');
                
                // Get the container
                const container = item.parentNode;
                
                // Insert the item based on mouse position
                if (mouseY < threshold) {
                    container.insertBefore(draggedItem, item);
                } else {
                    container.insertBefore(draggedItem, item.nextSibling);
                }
                
                // Trigger auto-save to save the new order
                triggerAutoSave();
            }
            // Handle drop on empty containers
            else {
                const container = e.target.closest('.items-container');
                if (draggedItem && container) {
                    // Remove container drag-over class
                    container.classList.remove('container-drag-over');
                    
                    // Append to the container
                    container.appendChild(draggedItem);
                    
                    // Trigger auto-save to save the new order and risk level
                    triggerAutoSave();
                }
            }
            
            return false;
        }

        // Initialize drag and drop for all containers
        function initializeDragAndDrop() {
            // Initialize items
            const items = document.querySelectorAll('.item');
            items.forEach(item => {
                initializeDragForItem(item);
            });
            
            // Initialize containers
            const containers = document.querySelectorAll('.items-container');
            containers.forEach(container => {
                container.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dragging if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // If container is empty or doesn't contain the dragged item
                    if (draggedItem && (!this.contains(draggedItem) || this.children.length === 0)) {
                        // Remove drag-over class from all containers
                        const containers = document.querySelectorAll('.items-container');
                        containers.forEach(c => c.classList.remove('container-drag-over'));
                        
                        // Add drag-over class to this container
                        this.classList.add('container-drag-over');
                    }
                });
                
                container.addEventListener('drop', function(e) {
                    e.preventDefault();
                    
                    // Don't allow dropping if any cell is being edited
                    if (currentlyEditingCell) {
                        return;
                    }
                    
                    // If we have a dragged item and we're not dropping on another item
                    if (draggedItem && !e.target.closest('.item')) {
                        // Remove container drag-over class
                        this.classList.remove('container-drag-over');
                        
                        // Append to the container
                        this.appendChild(draggedItem);
                        
                        // Trigger auto-save to save the new order and risk level
                        triggerAutoSave();
                    }
                });
            });
        }

        // Load saved items when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const savedItems = JSON.parse('{{ saved_items_json | safe }}' || '[]');
            
            console.log('Loading saved items:', savedItems);
            
            // Create a map to track items we've already added
            const addedItems = new Set();
            
            savedItems.forEach(item => {
                if (item.category === currentCategory) {
                    // Skip if we've already added this item
                    if (item.id && addedItems.has(item.id)) {
                        console.log('Skipping duplicate item:', item.id);
                        return;
                    }
                    
                    // Find the correct container
                    const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                        .find(row => row.querySelector('.entity-title').textContent === item.entity);
                    
                    if (entityRow) {
                        const riskColumn = entityRow.querySelector(
                            item.risk_level === 'No' ? '.no-risk' :
                            item.risk_level === 'At' ? '.at-risk' :
                            '.high-risk'
                        );
                        
                        if (riskColumn) {
                            const container = riskColumn.querySelector('.items-container');
                            const itemElement = document.createElement('div');
                            itemElement.className = 'item';
                            itemElement.setAttribute('draggable', 'true');
                            itemElement.setAttribute('data-entity', item.entity);
                            itemElement.setAttribute('data-risk', item.risk_level);
                            itemElement.setAttribute('data-item-id', item.id || generateUUID());
                            
                            // Use empty string if rating is null, undefined, or empty
                            const ratingValue = item.rating || '';
                            
                            itemElement.innerHTML = `
                                <i class="bi bi-grip-vertical drag-handle"></i>
                                <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)">${item.text}</div>
                                <div class="item-rating" onclick="showRatingSelector(this)">${ratingValue}</div>
                                <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                            `;
                            container.appendChild(itemElement);
                            
                            // Add click handler to make text editable when clicked
                            const textElement = itemElement.querySelector('.item-text');
                            textElement.addEventListener('click', function(e) {
                                // Prevent editing if cell is being edited by another user
                                if (textElement.classList.contains('cell-editing-other')) {
                                    e.preventDefault();
                    return;
                }
                
                                if (textElement.getAttribute('contenteditable') === 'false') {
                                    textElement.setAttribute('contenteditable', 'true');
                                    textElement.focus();
                                }
                            });
                            
                            // Initialize drag and drop for this item
                            initializeDragForItem(itemElement);
                            
                            // Mark this item as added
                            if (item.id) {
                                addedItems.add(item.id);
                            }
                        }
                    }
                }
            });
            
            // Set up realtime subscription
            const channels = setupRealtimeSubscription();
            
            // Clean up subscription when page unloads
            window.addEventListener('beforeunload', () => {
                console.log('Cleaning up subscription...');
                
                // Broadcast that we stopped editing any cell
                if (currentlyEditingCell) {
                    broadcastEditingStatus(currentlyEditingCell, false);
                }
                
                channels.forEach(channel => {
                    supabaseClient.removeChannel(channel);
            });
        });

            // Initialize drag and drop for all containers
            initializeDragAndDrop();
            
            // Check if this is the first visit
            if (localStorage.getItem('welcomeShown') !== 'true') {
                // Show welcome modal
                showWelcomeModal();
            } else {
                // Check if drag hint has been dismissed before
                if (localStorage.getItem('dragHintShown') === 'true') {
                    // Show help button immediately
                    showHelpButton();
                } else {
                    // Show drag hint after a short delay
                    setTimeout(showDragHint, 2000);
                }
            }
        });
        
        // Function to show welcome modal
        function showWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close welcome modal
        function closeWelcomeModal() {
            const modal = document.getElementById('welcome-modal');
            modal.style.display = 'none';
            
            // Mark as shown
            localStorage.setItem('welcomeShown', 'true');
            
            // Show drag hint after closing welcome modal
            setTimeout(showDragHint, 1000);
        }
        
        // Function to update welcome preference
        function updateWelcomePreference() {
            const checkbox = document.getElementById('dont-show-welcome');
            if (checkbox.checked) {
                localStorage.setItem('welcomeShown', 'true');
                } else {
                localStorage.removeItem('welcomeShown');
            }
        }
        
        // Function to show drag hint
        function showDragHint(forceShow = false) {
            // If forceShow is true, show the hint regardless of localStorage
            if (!forceShow) {
                // Check if user has dismissed drag hint before
                if (localStorage.getItem('dragHintShown') === 'true') {
                    // Show the help button instead
                    showHelpButton();
                    return;
                }
            }
            
            // Hide help button when showing the hint
            hideHelpButton();
            
            const dragHint = document.getElementById('drag-hint');
            dragHint.style.display = 'flex';
            
            // Start rotating tips
            startRotatingTips();
            
            // Hide hint after 30 seconds if not forced
            if (!forceShow) {
                setTimeout(() => {
                    dragHint.style.display = 'none';
                    stopRotatingTips();
                    showHelpButton();
                }, 30000);
            }
        }
        
        // Function to close drag hint
        function closeDragHint() {
            const dragHint = document.getElementById('drag-hint');
            dragHint.style.display = 'none';
            
            // Stop rotating tips
            stopRotatingTips();
            
            // Remember that user has dismissed drag hint
            localStorage.setItem('dragHintShown', 'true');
            
            // Show the help button
            showHelpButton();
        }
        
        // Function to show help button
        function showHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.add('visible');
        }
        
        // Function to hide help button
        function hideHelpButton() {
            const helpButton = document.getElementById('help-floating-btn');
            helpButton.classList.remove('visible');
        }
        
        // Tips array
        const tips = [
            "Du kan dra i cellen för att ändra ordning på objekten.",
            "Klicka på texten för att redigera den.",
            "Klicka på betygsområdet för att välja ett betyg.",
            "Ändringar sparas automatiskt när du slutar redigera.",
            "Använd plus-knappen för att lägga till nya objekt.",
            "Dra objekt mellan kolumner för att ändra risknivå.",
        ];
        
        let currentTipIndex = 0;
        let tipsInterval = null;
        
        // Function to start rotating tips
        function startRotatingTips() {
            // Set initial tip
            updateTipDisplay();
            
            // Add transition for smooth fade effect
            const tipText = document.getElementById('drag-hint-text');
            tipText.style.transition = 'opacity 0.3s ease';
            
            // Rotate through tips every 5 seconds
            tipsInterval = setInterval(nextTip, 5000);
        }
        
        // Function to stop rotating tips
        function stopRotatingTips() {
            if (tipsInterval) {
                clearInterval(tipsInterval);
                tipsInterval = null;
            }
        }
        
        // Function to update the tip display
        function updateTipDisplay() {
            const tipText = document.getElementById('drag-hint-text');
            const currentTipElement = document.getElementById('current-tip');
            const totalTipsElement = document.getElementById('total-tips');
            
            // Update tip text
            tipText.innerHTML = tips[currentTipIndex];
            
            // Update counter
            currentTipElement.textContent = currentTipIndex + 1;
            totalTipsElement.textContent = tips.length;
        }
        
        // Function to show next tip
        function nextTip() {
            const tipText = document.getElementById('drag-hint-text');
            
            // Fade out
            tipText.style.opacity = '0';
            
            // Change to next tip
            setTimeout(() => {
                currentTipIndex = (currentTipIndex + 1) % tips.length;
                updateTipDisplay();
                tipText.style.opacity = '1';
            }, 300);
        }
        
        // Function to show previous tip
        function previousTip() {
            const tipText = document.getElementById('drag-hint-text');
            
            // Fade out
            tipText.style.opacity = '0';
            
            // Change to previous tip
            setTimeout(() => {
                currentTipIndex = (currentTipIndex - 1 + tips.length) % tips.length;
                updateTipDisplay();
                tipText.style.opacity = '1';
            }, 300);
        }
        
        // Function to show shortcuts modal
        function showShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'flex';
        }
        
        // Function to close shortcuts modal
        function closeShortcutsModal() {
            const modal = document.getElementById('shortcuts-modal');
            modal.style.display = 'none';
        }
        
        // Handle keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Show shortcuts modal when '?' is pressed
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                showShortcutsModal();
                e.preventDefault();
            }
            
            // Close modal with Escape key
            if (e.key === 'Escape' && document.getElementById('shortcuts-modal').style.display === 'flex') {
                closeShortcutsModal();
                e.preventDefault();
            }
            
            // Ctrl+S to save manually
            if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                saveDataToSupabase();
                e.preventDefault();
            }
            
            // Ctrl+N to add new item in the first column
            if (e.key === 'n' && (e.ctrlKey || e.metaKey)) {
                // Find the first add button and click it
                const firstAddButton = document.querySelector('.add-item-btn');
                if (firstAddButton) {
                    firstAddButton.click();
                }
                e.preventDefault();
            }
            
            // Delete key to remove selected item
            if (e.key === 'Delete' && currentlyEditingCell) {
                const item = currentlyEditingCell.closest('.item');
                if (item) {
                    const deleteButton = item.querySelector('.delete-btn');
                    if (deleteButton) {
                        deleteButton.click();
                    }
                }
            }
            
            // Enter key to finish editing
            if (e.key === 'Enter' && currentlyEditingCell) {
                currentlyEditingCell.blur();
                e.preventDefault();
            }
        });
        
        // Close modal when clicking outside
        window.addEventListener('click', function(e) {
            const modal = document.getElementById('shortcuts-modal');
            if (e.target === modal) {
                closeShortcutsModal();
            }
        });

        // Function to show status message
        function showStatusMessage(message, isSuccess) {
            const statusMessage = document.getElementById('status-message');
            statusMessage.textContent = message;
            statusMessage.className = 'status-message';
            
            if (isSuccess) {
                statusMessage.classList.add('success-message');
            } else {
                statusMessage.classList.add('error-message');
            }
            
            statusMessage.style.display = 'block';
            
            // Hide message after 5 seconds
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }

        // Handle new item
        function handleNewItem(payload) {
            console.log('New item update:', payload);
            
            // If this is our own update, ignore it
            if (payload.payload.userId === sessionUserId) {
                return;
            }
            
            const { entityId, riskLevel, itemId } = payload.payload;
            
            // Check if this item already exists (to avoid duplicates)
            const existingItem = document.querySelector(`.item[data-item-id="${itemId}"]`);
            if (existingItem) {
                console.log('Item already exists, not creating duplicate');
                return;
            }
            
            // Also check if there's an item with the same entity and risk level that's empty
            // This helps prevent duplicates when a user is still editing a newly created item
            const emptyItems = document.querySelectorAll(`.item[data-entity="${entityId}"][data-risk="${riskLevel}"]`);
            for (const item of emptyItems) {
                const textElement = item.querySelector('.item-text');
                const ratingElement = item.querySelector('.item-rating');
                
                // If we find an empty item, use that instead of creating a new one
                if (!textElement.textContent.trim() && !ratingElement.textContent.trim()) {
                    console.log('Found empty item, using it instead of creating a new one');
                    item.setAttribute('data-item-id', itemId);
                    return;
                }
            }
            
            // Find the correct container
            const entityRow = Array.from(document.querySelectorAll('.entity-row'))
                .find(row => row.querySelector('.entity-title').textContent === entityId);
            
            if (entityRow) {
                const riskColumn = entityRow.querySelector(
                    riskLevel === 'No' ? '.no-risk' :
                    riskLevel === 'At' ? '.at-risk' :
                    '.high-risk'
                );
                
                if (riskColumn) {
                    const container = riskColumn.querySelector('.items-container');
                    
                    // Create new item
                    const itemElement = document.createElement('div');
                    itemElement.className = 'item';
                    itemElement.setAttribute('draggable', 'true');
                    itemElement.setAttribute('data-entity', entityId);
                    itemElement.setAttribute('data-risk', riskLevel);
                    itemElement.setAttribute('data-item-id', itemId);
                    
                    itemElement.innerHTML = `
                        <i class="bi bi-grip-vertical drag-handle"></i>
                        <div class="item-text" contenteditable="false" onblur="handleCellChange(this)" onfocus="handleCellFocus(this)"></div>
                        <div class="item-rating" onclick="showRatingSelector(this)"></div>
                        <button class="delete-btn" onclick="deleteItem(this)"><i class="bi bi-trash"></i></button>
                    `;
                    
                    // Add to container at the top
                    container.insertBefore(itemElement, container.firstChild);
                    
                    // Add click handler to make text editable when clicked
                    const textElement = itemElement.querySelector('.item-text');
                    textElement.addEventListener('click', function(e) {
                        // Prevent editing if cell is being edited by another user
                        if (textElement.classList.contains('cell-editing-other')) {
                            e.preventDefault();
                            return;
                        }
                        
                        if (textElement.getAttribute('contenteditable') === 'false') {
                            textElement.setAttribute('contenteditable', 'true');
                            textElement.focus();
                        }
                    });
                    
                    // Initialize drag and drop for this item
                    initializeDragForItem(itemElement);
                    
                    // Show a subtle notification that content was updated
                    const autoSaveIndicator = document.getElementById('auto-save-indicator');
                    autoSaveIndicator.innerHTML = 'Nytt objekt tillagt';
                    setTimeout(() => {
                        autoSaveIndicator.innerHTML = '';
                    }, 2000);
                }
            }
        }

        // Function to collect all items data
        function collectItemsData() {
            const items = [];
            const processedIds = new Set(); // Track processed IDs to avoid duplicates
            
            // Get all entity rows
            const entityRows = document.querySelectorAll('.entity-row');
            
            entityRows.forEach(entityRow => {
                const entity = entityRow.querySelector('.entity-title').textContent;
                
                // Get all risk columns in this entity row
                const riskColumns = entityRow.querySelectorAll('.risk-column');
                
                riskColumns.forEach(column => {
                    // Determine risk level
                    let riskLevel = 'Unknown';
                    if (column.classList.contains('no-risk')) riskLevel = 'No';
                    if (column.classList.contains('at-risk')) riskLevel = 'At';
                    if (column.classList.contains('high-risk')) riskLevel = 'High';
                    
                    // Get all items in this column
                    const itemElements = column.querySelectorAll('.item');
                    
                    itemElements.forEach((item, index) => {
                        const text = item.querySelector('.item-text').textContent.trim();
                        const rating = item.querySelector('.item-rating').textContent.trim();
                        const itemId = item.getAttribute('data-item-id');
                        
                        // Skip if we've already processed this ID (avoid duplicates)
                        if (processedIds.has(itemId)) {
                            console.log('Skipping duplicate item ID:', itemId);
                            return;
                        }
                        
                        // Only include items that have either text or rating
                        if (text || rating) {
                            items.push({
                                id: itemId,
                                text: text,
                                entity: entity,
                                risk_level: riskLevel,
                                category: currentCategory,
                                rating: rating,
                                position: index
                            });
                            
                            // Mark this ID as processed
                            processedIds.add(itemId);
                        }
                    });
                });
            });
            
            console.log('Collected items for saving:', items);
            return items;
        }
    </script>
</body>
</html>
